# [ CHUNK 1 of 15 ] Environment

import uuid
import logging
import requests
import pandas as pd
from typing import Dict, Any, Tuple
from random import randint
import gym
import numpy as np
from tensortrade.env.generic.observers import TensorTradeObserver
# Importing the TensorTradeActionScheme and its subclasses
from tensortrade.env.generic.actions import TensorTradeActionScheme, BSH, SimpleOrders, ManagedRiskOrders
from custom_components.my_custom_rewards import CustomRewardScheme
from tensortrade.env.generic.environment import TradingEnv
from tensortrade.oms.wallets import Wallet, Portfolio
from tensortrade.oms.instruments import USD, Instrument
from tensortrade.oms.services.execution.simulated import execute_order
from tensortrade.core import TimeIndexed, Clock, Component
from tensortrade.env.generic.stoppers import Stopper
from tensortrade.env.generic.informer import Informer
from tensortrade.env.generic.renderers import renderers
from tensortrade.env.generic.renderers import Renderer

from tensortrade.oms.exchanges import SimulatedExchange
from tensortrade.oms.exchanges import Exchange

from tensortrade.feed.DataFetch import DataFetch
from tensortrade.feed.DataFetch import fetch_historical_data
from tensortrade.feed.core import DataFeed, Stream


class TradingEnv(gym.Env, TimeIndexed):
    """A trading environment for use with Gym-compatible reinforcement learning algorithms.

    Attributes:
        action_scheme: Component for generating actions at each step.
        reward_scheme: Component for computing rewards after each step.
        observer: Component for generating observations after each step.
        informer: Component for providing information after each step.
        renderer: Component for rendering the environment.
        agent_id: Unique identifier for the agent using this environment.
        episode_id: Unique identifier for the current episode.
    """

    agent_id: str = None  # Unique identifier for the agent (if multiple agents are used)
    episode_id: str = None  # Unique identifier for each episode

    def __init__(self,
                 action_scheme: TensorTradeActionScheme,
                 observer: TensorTradeObserver,  # Change here
                 reward_scheme: RewardScheme = CustomRewardScheme(),
                 stopper: Stopper,
                 informer: Informer,
                 renderer: Renderer,
                 min_periods: int = None,
                 max_episode_steps: int = None,
                 random_start_pct: float = 0.00,
                 api_key: str = None,
                 symbol: str = None,
                 start_date: str = None,
                 end_date: str = None,
                 **kwargs) -> None:
        super().__init__()
        self.clock = Clock()

        self.action_scheme = action_scheme
        self.reward_scheme = reward_scheme
        self.observer = observer
        self.stopper = stopper
        self.informer = informer
        self.renderer = renderer
        self.min_periods = min_periods
        self.random_start_pct = random_start_pct
        self.api_key = '6E9HSRUQPIN8JL3I'  # Replace 'your_api_key' with your actual API key
        self.symbol = "BLDP"  # Replace 'your_symbol' with your actual symbol
        self.start_date = "2018-02-16"  # Replace 'YYYY-MM-DD' with your actual start date
        self.end_date = "2021-02-16"  # Replace 'YYYY-MM-DD' with your actual end date

        self.fetch_data()

        gym.envs.register(
            id='TensorTrade-v0',
            max_episode_steps=max_episode_steps,
        )
        self.spec = gym.spec('TensorTrade-v0')

        for c in self.components.values():
            c.clock = self.clock

        self.action_space = action_scheme.action_space
        self.observation_space = observer.observation_space

        self._enable_logger = kwargs.get('enable_logger', False)
        if self._enable_logger:
            self.logger = logging.getLogger(kwargs.get('logger_name', __name__))
            self.logger.setLevel(kwargs.get('log_level', logging.DEBUG))

        # Initialize agent and episode IDs if required
        self.agent_id = kwargs.get('agent_id', uuid.uuid4().hex)
        self.episode_id = kwargs.get('episode_id', uuid.uuid4().hex)

    def fetch_data(self) -> None:
        """Fetches historical trading data."""
        self.data = fetch_historical_data(self.symbol, self.api_key, self.start_date, self.end_date)

    @property
    def components(self) -> 'Dict[str, Component]':
        """The components of the environment. (`Dict[str,Component]`, read-only)"""
        return {
            "action_scheme": self.action_scheme,
            "reward_scheme": self.reward_scheme,
            "observer": self.observer, 
            "stopper": self.stopper,
            "informer": self.informer,
            "renderer": self.renderer
        }

    def step(self, action: Any) -> 'Tuple[np.array, float, bool, dict]':
        """Makes one step through the environment.

        Parameters
        ----------
        action : Any
            An action to perform on the environment.

        Returns
        -------
        `np.array`
            The observation of the environment after the action being
            performed.
        float
            The computed reward for performing the action.
        bool
            Whether or not the episode is complete.
        dict
            The information gathered after completing the step.
        """
        self.action_scheme.perform(self, action)

        obs = self.observer.observe(self)
        reward = self.reward_scheme.reward(self)
        done = self.stopper.stop(self)
        info = self.informer.info(self)

        self.clock.increment()

        return obs, reward, done, info

    def reset(self) -> 'np.array':
        """Resets the environment.

        Returns
        -------
        obs : `np.array`
            The first observation of the environment.
        """
        if self.random_start_pct > 0.00:
            size = len(self.observer.feed.process[-1].inputs[0].iterable)
            random_start = randint(0, int(size * self.random_start_pct))
        else:
            random_start = 0

        self.episode_id = str(uuid.uuid4())
        self.clock.reset()

        for c in self.components.values():
            if hasattr(c, "reset"):
                if isinstance(c, Observer):
                    c.reset(random_start=random_start)
                else:
                    c.reset()

        obs = self.observer.observe(self)

        self.clock.increment()

        return obs

    def render(self, **kwargs) -> None:
        """Renders the environment."""
        self.renderer.render(self, **kwargs)

    def save(self) -> None:
        """Saves the rendered view of the environment."""
        self.renderer.save()

    def close(self) -> None:
        """Closes the environment."""
        self.renderer.close()

def fetch_historical_data(symbol: str, api_key: str, start_date: str = None, end_date: str = None) -> pd.DataFrame:
    """
    Fetch historical 1-minute trading data using the Alpha Vantage API.
    """
    try:
        url = f"https://www.alphavantage.co/query?function=TIME_SERIES_INTRADAY&symbol={symbol}&interval=1min&apikey={api_key}&outputsize=full&datatype=csv"
        response = requests.get(url)
        if response.status_code != 200:
            raise ValueError(f"Error fetching data: Status code {response.status_code}")
        data = pd.read_csv(pd.compat.StringIO(response.text))
        return preprocess_data(data, start_date, end_date)
    except requests.exceptions.RequestException as e:
        logging.error(f"Request Exception: {e}")

def preprocess_data(data: pd.DataFrame, start_date: str = None, end_date: str = None) -> pd.DataFrame:
    """
    Preprocess and optionally filter data by date range, with error handling.
    """
    try:
        imputer = SimpleImputer(strategy='mean')
        data = pd.DataFrame(imputer.fit_transform(data), columns=data.columns)
        
        scaler = RobustScaler()
        data = pd.DataFrame(scaler.fit_transform(data), columns=data.columns)
        
        if start_date and end_date:
            data['timestamp'] = pd.to_datetime(data['timestamp'], errors='coerce')
            data = data[(data['timestamp'] >= pd.to_datetime(start_date)) & (data['timestamp'] <= pd.to_datetime(end_date))]

        # Perform feature selection within try block to catch potential errors
        if 'close' in data.columns:
            data = select_relevant_features(data, 'close')

    except Exception as e:
        logging.error(f"Error during data preprocessing: {e}")
        # Optionally, return an empty DataFrame or handle the issue as needed
        return pd.DataFrame()
        
    return data



# [ END OF CHUNK 1 ]






# [ CHUNK 2 of 15 ] CustomRewardScheme


from tensortrade.env.generic import RewardScheme

from tensortrade.env.generic import RewardScheme, TradingEnv
from tensortrade.feed.core import Stream, DataFeed

from abc import abstractmethod
import numpy as np
import pandas as pd
import math


from tensortrade.core.component import Component
from tensortrade.core.base import TimeIndexed


class CustomRewardScheme(RewardScheme):
    def __init__(self):
        super().__init__()
        # Initialize any necessary variables or parameters
        self.daily_trades = 0
        self.daily_wins = 0
        self.weekly_trades = 0
        self.weekly_wins = 0
        self.total_wins = 0
        self.total_losses = 0
        self.cumulative_profit_loss = 0

    def reward(self, env):
        # Example: Check if today's profit-loss is different and update daily stats
        current_price = env.portfolio.current_price
        portfolio = env.portfolio
        action = env.action

        # Assuming you have a method to calculate PnL
        profit_loss = (current_price - portfolio.initial_capital) * portfolio.positions
        self.cumulative_profit_loss += profit_loss
        profit_loss_percentage = profit_loss / portfolio.initial_capital * 100
        self.daily_trades += 1

        # Example reward calculation logic
        reward = profit_loss_percentage  # Simplified reward based on profit

        if profit_loss > 0:
            self.daily_wins += 1

        # Reset daily stats if necessary
        if env.clock.now() > env.clock.start + 24 * 60 * 60:  # Reset daily at midnight
            self.daily_trades = 0
            self.daily_wins = 0

        return reward

    def reset(self):
        # Reset state for new trading session
        self.daily_trades = 0
        self.daily_wins = 0
        self.weekly_trades = 0
        self.weekly_wins = 0
        self.total_wins = 0
        self.total_losses = 0
        self.cumulative_profit_loss = 0

        
        
        
class TensorTradeRewardScheme(RewardScheme):
    """An abstract base class for reward schemes for the default environment.
    """

    def reward(self, env: 'TradingEnv') -> float:
        return self.get_reward(env.action_scheme.portfolio)

    @abstractmethod
    def get_reward(self, portfolio) -> float:
        """Gets the reward associated with current step of the episode.

        Parameters
        ----------
        portfolio : `Portfolio`
            The portfolio associated with the `TensorTradeActionScheme`.

        Returns
        -------
        float
            The reward for the current step of the episode.
        """
        raise NotImplementedError()


class SimpleProfit(TensorTradeRewardScheme):
    """A simple reward scheme that rewards the agent for incremental increases
    in net worth.

    Parameters
    ----------
    window_size : int
        The size of the look back window for computing the reward.

    Attributes
    ----------
    window_size : int
        The size of the look back window for computing the reward.
    """

    def __init__(self, window_size: int = 1):
        self._window_size = self.default('window_size', window_size)

    def get_reward(self, portfolio: 'Portfolio') -> float:
        """Rewards the agent for incremental increases in net worth over a
        sliding window.

        Parameters
        ----------
        portfolio : `Portfolio`
            The portfolio being used by the environment.

        Returns
        -------
        float
            The cumulative percentage change in net worth over the previous
            `window_size` time steps.
        """
        net_worths = [nw['net_worth'] for nw in portfolio.performance.values()]
        if len(net_worths) > 1:
            return net_worths[-1] / net_worths[-min(len(net_worths), self._window_size + 1)] - 1.0
        else:
            return 0.0


class RiskAdjustedReturns(TensorTradeRewardScheme):
    """A reward scheme that rewards the agent for increasing its net worth,
    while penalizing more volatile strategies.

    Parameters
    ----------
    return_algorithm : {'sharpe', 'sortino'}, Default 'sharpe'.
        The risk-adjusted return metric to use.
    risk_free_rate : float, Default 0.
        The risk free rate of returns to use for calculating metrics.
    target_returns : float, Default 0
        The target returns per period for use in calculating the sortino ratio.
    window_size : int
        The size of the look back window for computing the reward.
    """

    def __init__(self,
                 return_algorithm: str = 'sharpe',
                 risk_free_rate: float = 0.,
                 target_returns: float = 0.,
                 window_size: int = 1) -> None:
        algorithm = self.default('return_algorithm', return_algorithm)

        assert algorithm in ['sharpe', 'sortino']

        if algorithm == 'sharpe':
            return_algorithm = self._sharpe_ratio
        elif algorithm == 'sortino':
            return_algorithm = self._sortino_ratio

        self._return_algorithm = return_algorithm
        self._risk_free_rate = self.default('risk_free_rate', risk_free_rate)
        self._target_returns = self.default('target_returns', target_returns)
        self._window_size = self.default('window_size', window_size)

    def _sharpe_ratio(self, returns: 'pd.Series') -> float:
        """Computes the sharpe ratio for a given series of a returns.

        Parameters
        ----------
        returns : `pd.Series`
            The returns for the `portfolio`.

        Returns
        -------
        float
            The sharpe ratio for the given series of a `returns`.

        References
        ----------
        .. [1] https://en.wikipedia.org/wiki/Sharpe_ratio
        """
        return (np.mean(returns) - self._risk_free_rate + 1e-9) / (np.std(returns) + 1e-9)

    def _sortino_ratio(self, returns: 'pd.Series') -> float:
        """Computes the sortino ratio for a given series of a returns.

        Parameters
        ----------
        returns : `pd.Series`
            The returns for the `portfolio`.

        Returns
        -------
        float
            The sortino ratio for the given series of a `returns`.

        References
        ----------
        .. [1] https://en.wikipedia.org/wiki/Sortino_ratio
        """
        downside_returns = returns.copy()
        downside_returns[returns < self._target_returns] = returns ** 2

        expected_return = np.mean(returns)
        downside_std = np.sqrt(np.std(downside_returns))

        return (expected_return - self._risk_free_rate + 1e-9) / (downside_std + 1e-9)

    def get_reward(self, portfolio: 'Portfolio') -> float:
        """Computes the reward corresponding to the selected risk-adjusted return metric.

        Parameters
        ----------
        portfolio : `Portfolio`
            The current portfolio being used by the environment.

        Returns
        -------
        float
            The reward corresponding to the selected risk-adjusted return metric.
        """
        net_worths = [nw['net_worth'] for nw in portfolio.performance.values()][-(self._window_size + 1):]
        returns = pd.Series(net_worths).pct_change().dropna()
        risk_adjusted_return = self._return_algorithm(returns)
        return risk_adjusted_return


class PBR(TensorTradeRewardScheme):
    """A reward scheme for position-based returns.

    * Let :math:`p_t` denote the price at time t.
    * Let :math:`x_t` denote the position at time t.
    * Let :math:`R_t` denote the reward at time t.

    Then the reward is defined as,
    :math:`R_{t} = (p_{t} - p_{t-1}) \cdot x_{t}`.

    Parameters
    ----------
    price : `Stream`
        The price stream to use for computing rewards.
    """

    registered_name = "pbr"

    def __init__(self, price: 'Stream') -> None:
        super().__init__()
        self.position = -1

        r = Stream.sensor(price, lambda p: p.value, dtype="float").diff()
        position = Stream.sensor(self, lambda rs: rs.position, dtype="float")

        reward = (position * r).fillna(0).rename("reward")

        self.feed = DataFeed([reward])
        self.feed.compile()

    def on_action(self, action: int) -> None:
        self.position = -1 if action == 0 else 1

    def get_reward(self, portfolio: 'Portfolio') -> float:
        return self.feed.next()["reward"]

    def reset(self) -> None:
        """Resets the `position` and `feed` of the reward scheme."""
        self.position = -1
        self.feed.reset()


_registry = {
    'simple': SimpleProfit,
    'risk-adjusted': RiskAdjustedReturns,
    'pbr': PBR,
}


def get(identifier: str) -> 'TensorTradeRewardScheme':
    """Gets the `RewardScheme` that matches with the identifier.

    Parameters
    ----------
    identifier : str
        The identifier for the `RewardScheme`

    Returns
    -------
    `TensorTradeRewardScheme`
        The reward scheme associated with the `identifier`.

    Raises
    ------
    KeyError:
        Raised if identifier is not associated with any `RewardScheme`
    """
    if identifier not in _registry.keys():
        msg = f"Identifier {identifier} is not associated with any `RewardScheme`."
        raise KeyError(msg)
    return _registry[identifier]()



################





class RewardScheme(Component, TimeIndexed):
    """A component to compute the reward at each step of an episode."""

    registered_name = "rewards"

    @abstractmethod
    def reward(self, env: 'TradingEnv') -> float:
        """Computes the reward for the current step of an episode.

        Parameters
        ----------
        env : `TradingEnv`
            The trading environment

        Returns
        -------
        float
            The computed reward.
        """
        raise NotImplementedError()

    def reset(self) -> None:
        """Resets the reward scheme."""
        pass



# [ END OF CHUNK 2 ]








# [ CHUNK 3 of 15 ] Feed

import pandas as pd
from tensortrade.feed.core import Stream, DataFeed
from tensortrade.feed.api import AlphaVantage
from tensortrade.data import preprocess
from tensortrade.data import Module

from tensortrade.feed.DataFetch import Datafetch
from tensortrade.feed.DataFetch import fetch_historical_data

# Define custom stream classes for data fetching and preprocessing
class AlphaVantageStream(Stream):
    def __init__(self, symbol: str, api_key: str, start_date: str, end_date: str, **kwargs):
        super().__init__()
        self.source = AlphaVantage(symbol=symbol, api_key=api_key, start_date=start_date, end_date=end_date, **kwargs)

    def forward(self):
        return self.source.fetch()

class PreprocessingStream(Stream):
    def __init__(self, stream: Stream, **kwargs):
        super().__init__()
        self.stream = stream
        self.module = Module(**kwargs)

    def forward(self):
        data = self.stream.value
        if data is not None:
            data = preprocess(data, self.module)
        return data

# Initialize custom stream objects for data fetching and preprocessing
symbol = "BLDP"  # Example symbol
api_key = 6E9HSRUQPIN8JL3I  # Your Alpha Vantage API key
start_date = "2018-02-16"
end_date = "2021-02-16"
alpha_vantage_stream = AlphaVantageStream(symbol=symbol, api_key=api_key, start_date=start_date, end_date=end_date)
preprocessing_stream = PreprocessingStream(alpha_vantage_stream, ma=[10, 50], volume_ma=[10, 50], **kwargs)

# Initialize DataFeed with custom stream objects
feed = DataFeed([alpha_vantage_stream, preprocessing_stream])

# Compile the DataFeed to organize stream processing order
feed.compile()

# Run the DataFeed to start feeding data into the environment
feed.run()


# [ END OF CHUNK 3 ]






# [ CHUNK 4 of 15 ] DataFetch

import requests
import pandas as pd
import logging
from tensortrade.feed.core import Stream, DataFeed
from tensortrade.env.generic import TradingEnv
from sklearn.impute import SimpleImputer
from sklearn.preprocessing import RobustScaler
from sklearn.feature_selection import mutual_info_regression
from typing import Optional, Tuple

from tensortrade.oms.exchanges import Exchange
from tensortrade.oms.instruments import USD, Instrument
from tensortrade.feed import DataFetch






class DataFetchError(Exception):
    """Custom exception for data fetching and preprocessing errors."""
    pass




class DataFetchError(Exception):
    """Custom exception for data fetching and preprocessing errors."""
    pass

def fetch_historical_data(symbol: str, api_key: str, start_date: Optional[str] = None, end_date: Optional[str] = None) -> pd.DataFrame:
    """
    Fetch historical 1-minute trading data using the Alpha Vantage API.

    Args:
        symbol (str): The stock symbol for which to fetch data.
        api_key (str): The API key for Alpha Vantage.
        start_date (str, optional): The start date in the format "YYYY-MM-DD".
        end_date (str, optional): The end date in the format "YYYY-MM-DD".

    Returns:
        pd.DataFrame: The preprocessed historical trading data.

    Raises:
        DataFetchError: If there is an error fetching or preprocessing the data.
    """
    try:
        url = f"https://www.alphavantage.co/query?function=TIME_SERIES_INTRADAY&symbol={symbol}&interval=1min&apikey={api_key}&outputsize=full&datatype=csv"
        response = requests.get(url)
        response.raise_for_status()

        data = pd.read_csv(pd.compat.StringIO(response.text))
        data = preprocess_data(data, start_date, end_date)
        return data

    except requests.exceptions.RequestException as e:
        raise DataFetchError(f"Request Exception: {e}")
    except Exception as e:
        raise DataFetchError(f"Error fetching or preprocessing data: {e}")

def preprocess_data(data: pd.DataFrame, start_date: Optional[str] = None, end_date: Optional[str] = None) -> pd.DataFrame:
    """
    Preprocess and optionally filter data by date range.

    Args:
        data (pd.DataFrame): The raw data to be preprocessed.
        start_date (str, optional): The start date in the format "YYYY-MM-DD".
        end_date (str, optional): The end date in the format "YYYY-MM-DD".

    Returns:
        pd.DataFrame: The preprocessed data.
    """
    try:
        imputer = SimpleImputer(strategy='mean')
        data = pd.DataFrame(imputer.fit_transform(data), columns=data.columns)

        scaler = RobustScaler()
        data = pd.DataFrame(scaler.fit_transform(data), columns=data.columns)

        if start_date and end_date:
            data['timestamp'] = pd.to_datetime(data['timestamp'], utc=True, errors='coerce')
            data = data[(data['timestamp'] >= pd.to_datetime(start_date, utc=True)) & (data['timestamp'] <= pd.to_datetime(end_date, utc=True))]

        data = select_relevant_features(data, 'close')

        return data

    except Exception as e:
        raise DataFetchError(f"Error during data preprocessing: {e}")

def select_relevant_features(data: pd.DataFrame, target_column: str) -> pd.DataFrame:
    """
    Select a fixed number of top features based on mutual information with the target column.

    Args:
        data (pd.DataFrame): The input data containing features and the target column.
        target_column (str): The name of the target column.

    Returns:
        pd.DataFrame: The input data with only the selected relevant features and the target column.

    Raises:
        DataFetchError: If there is an error during feature selection.
    """
    try:
        if target_column not in data.columns:
            raise DataFetchError(f"Target column '{target_column}' not found in data.")

        # Drop the target column to isolate features
        X = data.drop(columns=[target_column])
        y = data[target_column]

        mutual_info = mutual_info_regression(X, y)

        # Create a Series for feature importance
        feature_importance = pd.Series(mutual_info, index=X.columns)

        # Select top N features based on mutual information
        N = 5  # Adjustable based on your requirement
        selected_features = feature_importance.nlargest(N).index.tolist()

        # Make sure the target column is included in the returned data
        selected_features.append(target_column)

        # Return only the selected features and the target
        return data[selected_features]

    except Exception as e:
        raise DataFetchError(f"Error during feature selection: {e}")

# Fetch historical data
api_key = "6E9HSRUQPIN8JL3I"
symbol = "BLDP"
start_date = "2018-02-16"
end_date = "2021-02-16"

try:
    data = fetch_historical_data(symbol, api_key, start_date, end_date)
except DataFetchError as e:
    logging.error(e)
    # Handle the error appropriately (e.g., exit gracefully, retry, or provide a default value)
else:
    # Create Stream objects for each feature
    price_stream = Stream.source(data['close'], dtype="float")  # Assuming 'close' is one of the columns in the DataFrame
    open_stream = Stream.source(data['open'], dtype="float")
    high_stream = Stream.source(data['high'], dtype="float")
    low_stream = Stream.source(data['low'], dtype="float")
    volume_stream = Stream.source(data['volume'], dtype="int")  # Assuming 'volume' is an integer column

    # Create a DataFeed from the Stream objects
    feed = DataFeed([price_stream, open_stream, high_stream, low_stream, volume_stream])

    # Define your trading environment
    env = TradingEnv(..., observer=feed, ...)


# [ END OF CHUNK 4 ]









# [ CHUNK 5 of 15 ] Observers


from typing import List


import datetime as dt
import numpy as np
import pandas as pd

from gym.spaces import Box, Space
from random import randrange


from tensortrade.feed.core import Stream, NameSpace, DataFeed
from tensortrade.oms.wallets import Wallet
from tensortrade.env.generic import Observer
from collections import OrderedDict


def _create_wallet_source(wallet: 'Wallet', include_worth: bool = True) -> 'List[Stream[float]]':
    """Creates a list of streams to describe a `Wallet`.

    Parameters
    ----------
    wallet : `Wallet`
        The wallet to make streams for.
    include_worth : bool, default True
        Whether or

    Returns
    -------
    `List[Stream[float]]`
        A list of streams to describe the `wallet`.
    """
    exchange_name = wallet.exchange.name
    symbol = wallet.instrument.symbol

    streams = []

    with NameSpace(exchange_name + ":/" + symbol):
        free_balance = Stream.sensor(wallet, lambda w: w.balance.as_float(), dtype="float").rename("free")
        locked_balance = Stream.sensor(wallet, lambda w: w.locked_balance.as_float(), dtype="float").rename("locked")
        total_balance = Stream.sensor(wallet, lambda w: w.total_balance.as_float(), dtype="float").rename("total")

        streams += [free_balance, locked_balance, total_balance]

        if include_worth:
            price = Stream.select(wallet.exchange.streams(), lambda node: node.name.endswith(symbol))
            worth = price.mul(total_balance).rename('worth')
            streams += [worth]

    return streams


def _create_internal_streams(portfolio: 'Portfolio') -> 'List[Stream[float]]':
    """Creates a list of streams to describe a `Portfolio`.

    Parameters
    ----------
    portfolio : `Portfolio`
        The portfolio to make the streams for.

    Returns
    -------
    `List[Stream[float]]`
        A list of streams to describe the `portfolio`.
    """
    base_symbol = portfolio.base_instrument.symbol
    sources = []

    for wallet in portfolio.wallets:
        symbol = wallet.instrument.symbol
        sources += wallet.exchange.streams()
        sources += _create_wallet_source(wallet, include_worth=(symbol != base_symbol))

    worth_streams = []
    for s in sources:
        if s.name.endswith(base_symbol + ":/total") or s.name.endswith("worth"):
            worth_streams += [s]

    net_worth = Stream.reduce(worth_streams).sum().rename("net_worth")
    sources += [net_worth]

    return sources


class ObservationHistory(object):
    """Stores observations from a given episode of the environment.

    Parameters
    ----------
    window_size : int
        The amount of observations to keep stored before discarding them.

    Attributes
    ----------
    window_size : int
        The amount of observations to keep stored before discarding them.
    rows : pd.DataFrame
        The rows of observations that are used as the environment observation
        at each step of an episode.

    """

    def __init__(self, window_size: int) -> None:
        self.window_size = window_size
        self.rows = OrderedDict()
        self.index = 0

    def push(self, row: dict) -> None:
        """Stores an observation.

        Parameters
        ----------
        row : dict
            The new observation to store.
        """
        self.rows[self.index] = row
        self.index += 1
        if len(self.rows.keys()) > self.window_size:
            del self.rows[list(self.rows.keys())[0]]

    def observe(self) -> 'np.array':
        """Gets the observation at a given step in an episode

        Returns
        -------
        `np.array`
            The current observation of the environment.
        """
        rows = self.rows.copy()

        if len(rows) < self.window_size:
            size = self.window_size - len(rows)
            padding = np.zeros((size, len(rows[list(rows.keys())[0]])))
            r = np.array([list(inner_dict.values()) for inner_dict in rows.values()])
            rows = np.concatenate((padding, r))

        if isinstance(rows, OrderedDict):
            rows = np.array([list(inner_dict.values()) for inner_dict in rows.values()])

        rows = np.nan_to_num(rows)

        return rows

    def reset(self) -> None:
        """Resets the observation history"""
        self.rows = OrderedDict()
        self.index = 0


class TensorTradeObserver(Observer):
    """The TensorTrade observer that is compatible with the other `default`
    components.

    Parameters
    ----------
    portfolio : `Portfolio`
        The portfolio to be used to create the internal data feed mechanism.
    feed : `DataFeed`
        The feed to be used to collect observations to the observation window.
    renderer_feed : `DataFeed`
        The feed to be used for giving information to the renderer.
    window_size : int
        The size of the observation window.
    min_periods : int
        The amount of steps needed to warmup the `feed`.
    **kwargs : keyword arguments
        Additional keyword arguments for observer creation.

    Attributes
    ----------
    feed : `DataFeed`
        The master feed in charge of streaming the internal, external, and
        renderer data feeds.
    window_size : int
        The size of the observation window.
    min_periods : int
        The amount of steps needed to warmup the `feed`.
    history : `ObservationHistory`
        The observation history.
    renderer_history : `List[dict]`
        The history of the renderer data feed.
    """

    def __init__(self,
                 portfolio: 'Portfolio',
                 feed: 'DataFeed' = None,
                 renderer_feed: 'DataFeed' = None,
                 window_size: int = 1,
                 min_periods: int = None,
                 **kwargs) -> None:
        internal_group = Stream.group(_create_internal_streams(portfolio)).rename("internal")
        external_group = Stream.group(feed.inputs).rename("external")

        if renderer_feed:
            renderer_group = Stream.group(renderer_feed.inputs).rename("renderer")

            self.feed = DataFeed([
                internal_group,
                external_group,
                renderer_group
            ])
        else:
            self.feed = DataFeed([
                internal_group,
                external_group
            ])

        self.window_size = window_size
        self.min_periods = min_periods

        self._observation_dtype = kwargs.get('dtype', np.float32)
        self._observation_lows = kwargs.get('observation_lows', -np.inf)
        self._observation_highs = kwargs.get('observation_highs', np.inf)

        self.history = ObservationHistory(window_size=window_size)

        initial_obs = self.feed.next()["external"]
        n_features = len(initial_obs.keys())

        self._observation_space = Box(
            low=self._observation_lows,
            high=self._observation_highs,
            shape=(self.window_size, n_features),
            dtype=self._observation_dtype
        )

        self.feed = self.feed.attach(portfolio)

        self.renderer_history = []

        self.feed.reset()
        self.warmup()

    @property
    def observation_space(self) -> Space:
        return self._observation_space

    def warmup(self) -> None:
        """Warms up the data feed.
        """
        if self.min_periods is not None:
            for _ in range(self.min_periods):
                if self.has_next():
                    obs_row = self.feed.next()["external"]
                    self.history.push(obs_row)

    def observe(self, env: 'TradingEnv') -> np.array:
        """Observes the environment.

        As a consequence of observing the `env`, a new observation is generated
        from the `feed` and stored in the observation history.

        Returns
        -------
        `np.array`
            The current observation of the environment.
        """
        data = self.feed.next()

        # Save renderer information to history
        if "renderer" in data.keys():
            self.renderer_history += [data["renderer"]]

        # Push new observation to observation history
        obs_row = data["external"]
        self.history.push(obs_row)

        obs = self.history.observe()
        obs = obs.astype(self._observation_dtype)
        return obs

    def has_next(self) -> bool:
        """Checks if there is another observation to be generated.

        Returns
        -------
        bool
            Whether there is another observation to be generated.
        """
        return self.feed.has_next()

    def reset(self, random_start=0) -> None:
        """Resets the observer"""
        self.renderer_history = []
        self.history.reset()
        self.feed.reset(random_start)
        self.warmup()


class IntradayObserver(Observer):
    """The IntradayObserver observer that is compatible with the other `default`
    components.
    Parameters
    ----------
    portfolio : `Portfolio`
        The portfolio to be used to create the internal data feed mechanism.
    feed : `DataFeed`
        The feed to be used to collect observations to the observation window.
    renderer_feed : `DataFeed`
        The feed to be used for giving information to the renderer.
    stop_time : datetime.time
        The time at which the episode will stop.
    window_size : int
        The size of the observation window.
    min_periods : int
        The amount of steps needed to warmup the `feed`.
    randomize : bool
        Whether or not to select a random episode when reset.
    **kwargs : keyword arguments
        Additional keyword arguments for observer creation.
    Attributes
    ----------
    feed : `DataFeed`
        The master feed in charge of streaming the internal, external, and
        renderer data feeds.
    stop_time : datetime.time
        The time at which the episode will stop.
    window_size : int
        The size of the observation window.
    min_periods : int
        The amount of steps needed to warmup the `feed`.
    randomize : bool
        Whether or not a random episode is selected when reset.
    history : `ObservationHistory`
        The observation history.
    renderer_history : `List[dict]`
        The history of the renderer data feed.
    """

    def __init__(self,
                 portfolio: 'Portfolio',
                 feed: 'DataFeed' = None,
                 renderer_feed: 'DataFeed' = None,
                 stop_time: 'datetime.time' = dt.time(16, 0, 0),
                 window_size: int = 1,
                 min_periods: int = None,
                 randomize: bool = False,
                 **kwargs) -> None:
        internal_group = Stream.group(_create_internal_streams(portfolio)).rename("internal")
        external_group = Stream.group(feed.inputs).rename("external")

        if renderer_feed:
            renderer_group = Stream.group(renderer_feed.inputs).rename("renderer")

            self.feed = DataFeed([
                internal_group,
                external_group,
                renderer_group
            ])
        else:
            self.feed = DataFeed([
                internal_group,
                external_group
            ])

        self.stop_time = stop_time
        self.window_size = window_size
        self.min_periods = min_periods
        self.randomize = randomize

        self._observation_dtype = kwargs.get('dtype', np.float32)
        self._observation_lows = kwargs.get('observation_lows', -np.inf)
        self._observation_highs = kwargs.get('observation_highs', np.inf)

        self.history = ObservationHistory(window_size=window_size)

        initial_obs = self.feed.next()["external"]
        initial_obs.pop('timestamp', None)
        n_features = len(initial_obs.keys())

        self._observation_space = Box(
            low=self._observation_lows,
            high=self._observation_highs,
            shape=(self.window_size, n_features),
            dtype=self._observation_dtype
        )

        self.feed = self.feed.attach(portfolio)

        self.renderer_history = []

        if self.randomize:
            self.num_episodes = 0
            while self.feed.has_next():
                ts = self.feed.next()["external"]["timestamp"]
                if ts.time() == self.stop_time:
                    self.num_episodes += 1

        self.feed.reset()
        self.warmup()

        self.stop = False

    @property
    def observation_space(self) -> Space:
        return self._observation_space

    def warmup(self) -> None:
        """Warms up the data feed.
        """
        if self.min_periods is not None:
            for _ in range(self.min_periods):
                if self.has_next():
                    obs_row = self.feed.next()["external"]
                    obs_row.pop('timestamp', None)
                    self.history.push(obs_row)

    def observe(self, env: 'TradingEnv') -> np.array:
        """Observes the environment.
        As a consequence of observing the `env`, a new observation is generated
        from the `feed` and stored in the observation history.
        Returns
        -------
        `np.array`
            The current observation of the environment.
        """
        data = self.feed.next()

        # Save renderer information to history
        if "renderer" in data.keys():
            self.renderer_history += [data["renderer"]]

        # Push new observation to observation history
        obs_row = data["external"]
        try:
            obs_ts = obs_row.pop('timestamp')
        except KeyError:
            raise KeyError("Include Stream of Timestamps named 'timestamp' in feed")
        self.history.push(obs_row)

        # Check if episode should be stopped
        if obs_ts.time() == self.stop_time:
            self.stop = True

        obs = self.history.observe()
        obs = obs.astype(self._observation_dtype)
        return obs

    def has_next(self) -> bool:
        """Checks if there is another observation to be generated.
        Returns
        -------
        bool
            Whether there is another observation to be generated.
        """
        return self.feed.has_next() and not self.stop

    def reset(self) -> None:
        """Resets the observer"""
        self.renderer_history = []
        self.history.reset()

        if self.randomize or not self.feed.has_next():
            self.feed.reset()
            if self.randomize:
                episode_num = 0
                while episode_num < randrange(self.num_episodes):
                    ts = self.feed.next()["external"]["timestamp"]
                    if ts.time() == self.stop_time:
                        episode_num += 1

        self.warmup()

        self.stop = False

# [ END OF CHUNK 5 ]






# [ CHUNK 6 of 15 ] Renderers

# Copyright 2020 The TensorTrade Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License

import os
import sys
import logging
import importlib

from abc import abstractmethod
from datetime import datetime
from typing import Union, Tuple
from collections import OrderedDict

import numpy as np
import pandas as pd

from IPython.display import display, clear_output
from pandas.plotting import register_matplotlib_converters

from tensortrade.oms.orders import TradeSide
from tensortrade.env.generic import Renderer, TradingEnv

from tensortrade.env.renderer import BaseRenderer, RenderableTradingEnv
from tensortrade.trades import TradeSide
from tensortrade.env.renderer





if importlib.util.find_spec("matplotlib"):
    import matplotlib.pyplot as plt

    from matplotlib import style

    style.use("ggplot")
    register_matplotlib_converters()

if importlib.util.find_spec("plotly"):
    import plotly.graph_objects as go

    from plotly.subplots import make_subplots


def _create_auto_file_name(filename_prefix: str,
                           ext: str,
                           timestamp_format: str = '%Y%m%d_%H%M%S') -> str:
    timestamp = datetime.now().strftime(timestamp_format)
    filename = filename_prefix + timestamp + '.' + ext
    return filename


def _check_path(path: str, auto_create: bool = True) -> None:
    if not path or os.path.exists(path):
        return

    if auto_create:
        os.mkdir(path)
    else:
        raise OSError(f"Path '{path}' not found.")


def _check_valid_format(valid_formats: list, save_format: str) -> None:
    if save_format not in valid_formats:
        raise ValueError("Acceptable formats are '{}'. Found '{}'".format("', '".join(valid_formats), save_format))


class BaseRenderer(Renderer):
    """The abstract base renderer to be subclassed when making a renderer
    the incorporates a `Portfolio`.
    """

    def __init__(self):
        super().__init__()
        self._max_episodes = None
        self._max_steps = None

    @staticmethod
    def _create_log_entry(episode: int = None,
                          max_episodes: int = None,
                          step: int = None,
                          max_steps: int = None,
                          date_format: str = "%Y-%m-%d %H:%M:%S") -> str:
        """
        Creates a log entry to be used by a renderer.

        Parameters
        ----------
        episode : int
            The current episode.
        max_episodes : int
            The maximum number of episodes that can occur.
        step : int
            The current step of the current episode.
        max_steps : int
            The maximum number of steps within an episode that can occur.
        date_format : str
            The format for logging the date.

        Returns
        -------
        str
            a log entry
        """
        log_entry = f"[{datetime.now().strftime(date_format)}]"

        if episode is not None:
            log_entry += f" Episode: {episode + 1}/{max_episodes if max_episodes else ''}"

        if step is not None:
            log_entry += f" Step: {step}/{max_steps if max_steps else ''}"

        return log_entry

    def render(self, env: 'TradingEnv', **kwargs):

        price_history = None
        if len(env.observer.renderer_history) > 0:
            price_history = pd.DataFrame(env.observer.renderer_history)

        performance = pd.DataFrame.from_dict(env.action_scheme.portfolio.performance, orient='index')

        self.render_env(
            episode=kwargs.get("episode", None),
            max_episodes=kwargs.get("max_episodes", None),
            step=env.clock.step,
            max_steps=kwargs.get("max_steps", None),
            price_history=price_history,
            net_worth=performance.net_worth,
            performance=performance.drop(columns=['base_symbol']),
            trades=env.action_scheme.broker.trades
        )

    @abstractmethod
    def render_env(self,
                   episode: int = None,
                   max_episodes: int = None,
                   step: int = None,
                   max_steps: int = None,
                   price_history: 'pd.DataFrame' = None,
                   net_worth: 'pd.Series' = None,
                   performance: 'pd.DataFrame' = None,
                   trades: 'OrderedDict' = None) -> None:
        """Renderers the current state of the environment.

        Parameters
        ----------
        episode : int
            The episode that the environment is being rendered for.
        max_episodes : int
            The maximum number of episodes that will occur.
        step : int
            The step of the current episode that is happening.
        max_steps : int
            The maximum number of steps that will occur in an episode.
        price_history : `pd.DataFrame`
            The history of instrument involved with the environment. The
            required columns are: date, open, high, low, close, and volume.
        net_worth : `pd.Series`
            The history of the net worth of the `portfolio`.
        performance : `pd.Series`
            The history of performance of the `portfolio`.
        trades : `OrderedDict`
            The history of trades for the current episode.
        """
        raise NotImplementedError()

    def save(self) -> None:
        """Saves the rendering of the `TradingEnv`.
        """
        pass

    def reset(self) -> None:
        """Resets the renderer.
        """
        pass


class EmptyRenderer(Renderer):
    """A renderer that does renders nothing.

    Needed to make sure that environment can function without requiring a
    renderer.
    """

    def render(self, env, **kwargs):
        pass


class ScreenLogger(BaseRenderer):
    """Logs information the screen of the user.

    Parameters
    ----------
    date_format : str
        The format for logging the date.
    """

    DEFAULT_FORMAT: str = "[%(asctime)-15s] %(message)s"

    def __init__(self, date_format: str = "%Y-%m-%d %H:%M:%S"):
        super().__init__()
        self._date_format = date_format

    def render_env(self,
                   episode: int = None,
                   max_episodes: int = None,
                   step: int = None,
                   max_steps: int = None,
                   price_history: pd.DataFrame = None,
                   net_worth: pd.Series = None,
                   performance: pd.DataFrame = None,
                   trades: 'OrderedDict' = None):
        print(self._create_log_entry(episode, max_episodes, step, max_steps, date_format=self._date_format))


class FileLogger(BaseRenderer):
    """Logs information to a file.

    Parameters
    ----------
    filename : str
        The file name of the log file. If omitted, a file name will be
        created automatically.
    path : str
        The path to save the log files to. None to save to same script directory.
    log_format : str
        The log entry format as per Python logging. None for default. For
        more details, refer to https://docs.python.org/3/library/logging.html
    timestamp_format : str
        The format of the timestamp of the log entry. Node for default.
    """

    DEFAULT_LOG_FORMAT: str = '[%(asctime)-15s] %(message)s'
    DEFAULT_TIMESTAMP_FORMAT: str = '%Y-%m-%d %H:%M:%S'

    def __init__(self,
                 filename: str = None,
                 path: str = 'log',
                 log_format: str = None,
                 timestamp_format: str = None) -> None:
        super().__init__()
        _check_path(path)

        if not filename:
            filename = _create_auto_file_name('log_', 'log')

        self._logger = logging.getLogger(self.id)
        self._logger.setLevel(logging.INFO)

        if path:
            filename = os.path.join(path, filename)
        handler = logging.FileHandler(filename)
        handler.setFormatter(
            logging.Formatter(
                log_format if log_format is not None else self.DEFAULT_LOG_FORMAT,
                datefmt=timestamp_format if timestamp_format is not None else self.DEFAULT_TIMESTAMP_FORMAT
            )
        )
        self._logger.addHandler(handler)

    @property
    def log_file(self) -> str:
        """The filename information is being logged to. (str, read-only)
        """
        return self._logger.handlers[0].baseFilename

    def render_env(self,
                   episode: int = None,
                   max_episodes: int = None,
                   step: int = None,
                   max_steps: int = None,
                   price_history: pd.DataFrame = None,
                   net_worth: pd.Series = None,
                   performance: pd.DataFrame = None,
                   trades: 'OrderedDict' = None) -> None:
        log_entry = self._create_log_entry(episode, max_episodes, step, max_steps)
        self._logger.info(f"{log_entry} - Performance:\n{performance}")


class PlotlyTradingChart(BaseRenderer):
    """Trading visualization for TensorTrade using Plotly.

    Parameters
    ----------
    display : bool
        True to display the chart on the screen, False for not.
    height : int
        Chart height in pixels. Affects both display and saved file
        charts. Set to None for 100% height. Default is None.
    save_format : str
        A format to save the chart to. Acceptable formats are
        html, png, jpeg, webp, svg, pdf, eps. All the formats except for
        'html' require Orca. Default is None for no saving.
    path : str
        The path to save the char to if save_format is not None. The folder
        will be created if not found.
    filename_prefix : str
        A string that precedes automatically-created file name
        when charts are saved. Default 'chart_'.
    timestamp_format : str
        The format of the date shown in the chart title.
    auto_open_html : bool
        Works for save_format='html' only. True to automatically
        open the saved chart HTML file in the default browser, False otherwise.
    include_plotlyjs : Union[bool, str]
        Whether to include/load the plotly.js library in the saved
        file. 'cdn' results in a smaller file by loading the library online but
        requires an Internet connect while True includes the library resulting
        in much larger file sizes. False to not include the library. For more
        details, refer to https://plot.ly/python-api-reference/generated/plotly.graph_objects.Figure.html

    Notes
    -----
    Possible Future Enhancements:
        - Saving images without using Orca.
        - Limit displayed step range for the case of a large number of steps and let
          the shown part of the chart slide after filling that range to keep showing
          recent data as it's being added.

    References
    ----------
    .. [1] https://plot.ly/python-api-reference/generated/plotly.graph_objects.Figure.html
    .. [2] https://plot.ly/python/figurewidget/
    .. [3] https://plot.ly/python/subplots/
    .. [4] https://plot.ly/python/reference/#candlestick
    .. [5] https://plot.ly/python/#chart-events
    """

    def __init__(self,
                 display: bool = True,
                 height: int = None,
                 timestamp_format: str = '%Y-%m-%d %H:%M:%S',
                 save_format: str = None,
                 path: str = 'charts',
                 filename_prefix: str = 'chart_',
                 auto_open_html: bool = False,
                 include_plotlyjs: Union[bool, str] = 'cdn') -> None:
        super().__init__()
        self._height = height
        self._timestamp_format = timestamp_format
        self._save_format = save_format
        self._path = path
        self._filename_prefix = filename_prefix
        self._include_plotlyjs = include_plotlyjs
        self._auto_open_html = auto_open_html

        if self._save_format and self._path and not os.path.exists(path):
            os.mkdir(path)

        self.fig = None
        self._price_chart = None
        self._volume_chart = None
        self._performance_chart = None
        self._net_worth_chart = None
        self._base_annotations = None
        self._last_trade_step = 0
        self._show_chart = display

    def _create_figure(self, performance_keys: dict) -> None:
        fig = make_subplots(
            rows=4, cols=1, shared_xaxes=True, vertical_spacing=0.03,
            row_heights=[0.55, 0.15, 0.15, 0.15],
        )
        fig.add_trace(go.Candlestick(name='Price', xaxis='x1', yaxis='y1',
                                     showlegend=False), row=1, col=1)
        fig.update_layout(xaxis_rangeslider_visible=False)

        fig.add_trace(go.Bar(name='Volume', showlegend=False,
                             marker={'color': 'DodgerBlue'}),
                      row=2, col=1)

        for k in performance_keys:
            fig.add_trace(go.Scatter(mode='lines', name=k), row=3, col=1)

        fig.add_trace(go.Scatter(mode='lines', name='Net Worth', marker={'color': 'DarkGreen'}),
                      row=4, col=1)

        fig.update_xaxes(linecolor='Grey', gridcolor='Gainsboro')
        fig.update_yaxes(linecolor='Grey', gridcolor='Gainsboro')
        fig.update_xaxes(title_text='Price', row=1)
        fig.update_xaxes(title_text='Volume', row=2)
        fig.update_xaxes(title_text='Performance', row=3)
        fig.update_xaxes(title_text='Net Worth', row=4)
        fig.update_xaxes(title_standoff=7, title_font=dict(size=12))

        self.fig = go.FigureWidget(fig)
        self._price_chart = self.fig.data[0]
        self._volume_chart = self.fig.data[1]
        self._performance_chart = self.fig.data[2]
        self._net_worth_chart = self.fig.data[-1]

        self.fig.update_annotations({'font': {'size': 12}})
        self.fig.update_layout(template='plotly_white', height=self._height, margin=dict(t=50))
        self._base_annotations = self.fig.layout.annotations

    def _create_trade_annotations(self,
                                  trades: 'OrderedDict',
                                  price_history: 'pd.DataFrame') -> 'Tuple[go.layout.Annotation]':
        """Creates annotations of the new trades after the last one in the chart.

        Parameters
        ----------
        trades : `OrderedDict`
            The history of trades for the current episode.
        price_history : `pd.DataFrame`
            The price history of the current episode.

        Returns
        -------
        `Tuple[go.layout.Annotation]`
            A tuple of annotations used in the renderering process.
        """
        annotations = []
        for trade in reversed(trades.values()):
            trade = trade[0]

            tp = float(trade.price)
            ts = float(trade.size)

            if trade.step <= self._last_trade_step:
                break

            if trade.side.value == 'buy':
                color = 'DarkGreen'
                ay = 15
                qty = round(ts / tp, trade.quote_instrument.precision)

                text_info = dict(
                    step=trade.step,
                    datetime=price_history.iloc[trade.step - 1]['date'],
                    side=trade.side.value.upper(),
                    qty=qty,
                    size=ts,
                    quote_instrument=trade.quote_instrument,
                    price=tp,
                    base_instrument=trade.base_instrument,
                    type=trade.type.value.upper(),
                    commission=trade.commission
                )

            elif trade.side.value == 'sell':
                color = 'FireBrick'
                ay = -15
                # qty = round(ts * tp, trade.quote_instrument.precision)

                text_info = dict(
                    step=trade.step,
                    datetime=price_history.iloc[trade.step - 1]['date'],
                    side=trade.side.value.upper(),
                    qty=ts,
                    size=round(ts * tp, trade.base_instrument.precision),
                    quote_instrument=trade.quote_instrument,
                    price=tp,
                    base_instrument=trade.base_instrument,
                    type=trade.type.value.upper(),
                    commission=trade.commission
                )
            else:
                raise ValueError(f"Valid trade side values are 'buy' and 'sell'. Found '{trade.side.value}'.")

            hovertext = 'Step {step} [{datetime}]<br>' \
                        '{side} {qty} {quote_instrument} @ {price} {base_instrument} {type}<br>' \
                        'Total: {size} {base_instrument} - Comm.: {commission}'.format(**text_info)

            annotations += [go.layout.Annotation(
                x=trade.step - 1, y=tp,
                ax=0, ay=ay, xref='x1', yref='y1', showarrow=True,
                arrowhead=2, arrowcolor=color, arrowwidth=4,
                arrowsize=0.8, hovertext=hovertext, opacity=0.6,
                hoverlabel=dict(bgcolor=color)
            )]

        if trades:
            self._last_trade_step = trades[list(trades)[-1]][0].step

        return tuple(annotations)

    def render_env(self,
                   episode: int = None,
                   max_episodes: int = None,
                   step: int = None,
                   max_steps: int = None,
                   price_history: pd.DataFrame = None,
                   net_worth: pd.Series = None,
                   performance: pd.DataFrame = None,
                   trades: 'OrderedDict' = None) -> None:
        # Validate inputs
        if price_history is None or net_worth is None or performance is None or trades is None:
            raise ValueError("Required positional arguments are missing for rendering.")

        if not isinstance(price_history, pd.DataFrame):
            raise ValueError("Price history must be a pandas DataFrame.")

        if not isinstance(net_worth, pd.Series):
            raise ValueError("Net worth must be a pandas Series.")

        if not isinstance(performance, pd.DataFrame):
            raise ValueError("Performance must be a pandas DataFrame.")

        if not isinstance(trades, OrderedDict):
            raise ValueError("Trades must be an OrderedDict.")

        if not self.fig:
            self._create_figure(performance.keys())

        if self._show_chart:  # ensure chart visibility through notebook cell reruns
            display(self.fig)

        try:
            self.fig.layout.title = self._create_log_entry(episode, max_episodes, step, max_steps)
            self._price_chart.update(dict(
                open=price_history['open'],
                high=price_history['high'],
                low=price_history['low'],
                close=price_history['close']
            ))
            self.fig.layout.annotations += self._create_trade_annotations(trades, price_history)
            self._volume_chart.update({'y': price_history['volume']})

            for trace in self.fig.select_traces(row=3):
                trace.update({'y': performance[trace.name]})

            self._net_worth_chart.update({'y': net_worth})

            if self._show_chart:
                self.fig.show()
        except Exception as e:
            # Handle rendering errors gracefully
            print(f"An error occurred during rendering: {e}")
            
            
            

    def save(self) -> None:
        """Saves the current chart to a file."""
        if not self._save_format:
            return
        else:
            valid_formats = ['html', 'png', 'jpeg', 'webp', 'svg', 'pdf', 'eps']
            _check_valid_format(valid_formats, self._save_format)

        _check_path(self._path)

        filename = _create_auto_file_name(self._filename_prefix, self._save_format)
        filename = os.path.join(self._path, filename)
        try:
            if self._save_format == 'html':
                self.fig.write_html(file=filename, include_plotlyjs='cdn', auto_open=self._auto_open_html)
            else:
                self.fig.write_image(filename)
        except Exception as e:
            # Handle saving errors gracefully
            print(f"An error occurred while saving the chart: {e}")

    
    
    def reset(self) -> None:
        self._last_trade_step = 0
        if self.fig is None:
            return

        self.fig.layout.annotations = self._base_annotations
        clear_output(wait=True)


class MatplotlibTradingChart(BaseRenderer):
    """ Trading visualization for TensorTrade using Matplotlib
    Parameters
    ---------
    display : bool
        True to display the chart on the screen, False for not.
    save_format : str
        A format to save the chart to. Acceptable formats are
        png, jpg, svg, pdf.
    path : str
        The path to save the chart to if save_format is not None. The folder
        will be created if not found.
    filename_prefix : str
        A string that precedes automatically-created file name
        when charts are saved. Default 'chart_'.
    """


    def __init__(self,
                 display: bool = True,
                 save_format: str = None,
                 path: str = 'charts',
                 filename_prefix: str = 'chart_',
                 chart_color: str = 'black',
                 chart_style: str = 'default',
                 chart_title: str = 'Trading Chart',
                 chart_title_fontsize: int = 14,
                 chart_title_color: str = 'black',
                 chart_xaxis_title: str = 'Time',
                 chart_yaxis_title: str = 'Price',
                 chart_xaxis_fontsize: int = 10,
                 chart_yaxis_fontsize: int = 10) -> None:
        super().__init__()
        self._volume_chart_height = 0.33

        self._df = None
        self.fig = None
        self._price_ax = None
        self._volume_ax = None
        self.net_worth_ax = None
        self._show_chart = display

        self._save_format = save_format
        self._path = path
        self._filename_prefix = filename_prefix

        if self._save_format and self._path and not os.path.exists(path):
            os.mkdir(path)

        self._chart_color = chart_color
        self._chart_style = chart_style
        self._chart_title = chart_title
        self._chart_title_fontsize = chart_title_fontsize
        self._chart_title_color = chart_title_color
        self._chart_xaxis_title = chart_xaxis_title
        self._chart_yaxis_title = chart_yaxis_title
        self._chart_xaxis_fontsize = chart_xaxis_fontsize
        self._chart_yaxis_fontsize = chart_yaxis_fontsize


    def set_price_chart_color(self, color):
        """Set color for price chart."""
        self._price_chart_color = color

    def set_volume_chart_color(self, color):
        """Set color for volume chart."""
        self._volume_chart_color = color

    def set_performance_chart_color(self, color):
        """Set color for performance chart."""
        self._performance_chart_color = color

    def set_net_worth_chart_color(self, color):
        """Set color for net worth chart."""
        self._net_worth_chart_color = color

    # Existing methods ...


    def _render_price_chart(self, ax, price_history):
        """Render price chart."""
        ax.plot(price_history.index, price_history['Close'], color=self._price_chart_color)
        ax.set_ylabel('Price')

    def _render_volume_chart(self, ax, price_history):
        """Render volume chart."""
        ax.bar(price_history.index, price_history['Volume'], color=self._volume_chart_color)
        ax.set_ylabel('Volume')

    def _render_performance_chart(self, ax, performance):
        """Render performance chart."""
        ax.plot(performance.index, performance['Portfolio Value'], color=self._performance_chart_color)
        ax.set_ylabel('Portfolio Value')

    def _render_net_worth(self, ax, net_worth):
        """Render net worth chart."""
        ax.plot(net_worth.index, net_worth, color=self._net_worth_chart_color)
        ax.set_ylabel('Net Worth')    


    def _create_figure(self) -> None:
        self.fig = plt.figure()

        self.net_worth_ax = plt.subplot2grid((6, 1), (0, 0), rowspan=2, colspan=1)
        self.price_ax = plt.subplot2grid((6, 1), (2, 0), rowspan=8,
                                         colspan=1, sharex=self.net_worth_ax)
        self.volume_ax = self.price_ax.twinx()
        plt.subplots_adjust(left=0.11, bottom=0.24, right=0.90, top=0.90, wspace=0.2, hspace=0)

    def _render_trades(self, ax, trades, price_history) -> None:
        if not trades:
            return

        trades = [trade for sublist in trades.values() for trade in sublist]

        for trade in trades:
            if trade.step in range(sys.maxsize):
                date = self._df.index.values[trade.step]
                close = self._df['close'].values[trade.step]
                color = 'green'

                if trade.side is TradeSide.SELL:
                    color = 'red'

                self.price_ax.annotate(' ', (date, close),
                                       xytext=(date, close),
                                       size="large",
                                       arrowprops=dict(arrowstyle='simple', facecolor=color))

    def _render_volume(self, step_range, times) -> None:
        self.volume_ax.clear()

        volume = np.array(self._df['volume'].values[step_range])

        self.volume_ax.plot(times, volume,  color='blue')
        self.volume_ax.fill_between(times, volume, color='blue', alpha=0.5)

        self.volume_ax.set_ylim(0, max(volume) / self._volume_chart_height)
        self.volume_ax.yaxis.set_ticks([])

    def _render_price(self, step_range, times, current_step) -> None:
        self.price_ax.clear()

        self.price_ax.plot(times, self._df['close'].values[step_range], color="black")

        last_time = self._df.index.values[current_step]
        last_close = self._df['close'].values[current_step]
        last_high = self._df['high'].values[current_step]

        self.price_ax.annotate('{0:.2f}'.format(last_close), (last_time, last_close),
                               xytext=(last_time, last_high),
                               bbox=dict(boxstyle='round',
                                         fc='w', ec='k', lw=1),
                               color="black",
                               fontsize="small")

        ylim = self.price_ax.get_ylim()
        self.price_ax.set_ylim(ylim[0] - (ylim[1] - ylim[0]) * self._volume_chart_height, ylim[1])

    def _render_net_worth(self, step_range, times, current_step, net_worths) -> None:
        """
        Renders the net worth chart for the given step range and net worth values.

        Parameters
        ----------
        step_range : slice
            The range of steps to render the net worth chart for.
        times : np.ndarray
            The array of timestamps corresponding to each step.
        current_step : int
            The current step being rendered.
        net_worths : np.ndarray
            The array of net worth values corresponding to each step.

        Returns
        -------
        None

        Notes
        -----
        This method plots the net worth chart on the Matplotlib figure. It clears the
        previous net worth plot, plots the new net worth values, and annotates the
        latest net worth value on the chart.

        The net worth chart displays the net worth of the trading portfolio over time,
        allowing users to visualize the performance of their trading strategy.
        """
        if not net_worths:
            return

        self.net_worth_ax.clear()
        self.net_worth_ax.plot(times, net_worths[step_range], label='Net Worth', color="g")
        self.net_worth_ax.legend()

        legend = self.net_worth_ax.legend(loc=2, ncol=2, prop={'size': 8})
        legend.get_frame().set_alpha(0.4)

        last_time = times[-1]
        last_net_worth = list(net_worths[step_range])[-1]

        self.net_worth_ax.annotate('{0:.2f}'.format(last_net_worth), (last_time, last_net_worth),
                                   xytext=(last_time, last_net_worth),
                                   bbox=dict(boxstyle='round',
                                             fc='w', ec='k', lw=1),
                                   color="black",
                                   fontsize="small")

        self.net_worth_ax.set_ylim(min(net_worths) / 1.25, max(net_worths) * 1.25)


    def render_env(self,
                   episode: int = None,
                   max_episodes: int = None,
                   step: int = None,
                   max_steps: int = None,
                   price_history: pd.DataFrame = None,
                   net_worth: pd.Series = None,
                   performance: pd.DataFrame = None,
                   trades: OrderedDict = None) -> None:
        # Validate inputs
        if price_history is None or net_worth is None or performance is None or trades is None:
            raise ValueError("Required positional arguments are missing for rendering.")

        if not isinstance(price_history, pd.DataFrame):
            raise ValueError("Price history must be a pandas DataFrame.")

        if not isinstance(net_worth, pd.Series):
            raise ValueError("Net worth must be a pandas Series.")

        if not isinstance(performance, pd.DataFrame):
            raise ValueError("Performance must be a pandas DataFrame.")

        if not isinstance(trades, OrderedDict):
            raise ValueError("Trades must be an OrderedDict.")

        fig, axs = plt.subplots(4, 1, figsize=self._figsize, sharex=True)

        try:
            self._render_price_chart(axs[0], price_history)
            self._render_volume_chart(axs[1], price_history)
            self._render_performance_chart(axs[2], performance)
            self._render_net_worth(axs[3], net_worth)
            self._render_trades(axs[0], trades, price_history)

            self._add_annotations(axs[0], trades, price_history)

            # Set title
            plt.suptitle(self._create_log_entry(episode, max_episodes, step, max_steps))

            if self._show_chart:
                plt.show()
        except Exception as e:
            # Handle rendering errors gracefully
            print(f"An error occurred during rendering: {e}")


    def save(self) -> None:
        """Saves the current chart to a file."""
        if not self._save_format:
            return
        else:
            valid_formats = ['png', 'jpeg', 'pdf', 'svg']
            _check_valid_format(valid_formats, self._save_format)

        _check_path(self._path)

        filename = _create_auto_file_name(self._filename_prefix, self._save_format)
        filename = os.path.join(self._path, filename)
        try:
            plt.savefig(filename, format=self._save_format, bbox_inches='tight')
            plt.close()
        except Exception as e:
            # Handle saving errors gracefully
            print(f"An error occurred while saving the chart: {e}")


    def reset(self) -> None:
        """Resets the renderer.
        """
        self.fig = None
        self._price_ax = None
        self._volume_ax = None
        self.net_worth_ax = None
        self._df = None


_registry = {
    "screen-log": ScreenLogger,
    "file-log": FileLogger,
    "plotly": PlotlyTradingChart,
    "matplot": MatplotlibTradingChart
}


def get(identifier: str) -> 'BaseRenderer':
    """Gets the `BaseRenderer` that matches the identifier.

    Parameters
    ----------
    identifier : str
        The identifier for the `BaseRenderer`

    Returns
    -------
    `BaseRenderer`
        The renderer associated with the `identifier`.

    Raises
    ------
    KeyError:
        Raised if identifier is not associated with any `BaseRenderer`
    """
    if identifier not in _registry.keys():
        msg = f"Identifier {identifier} is not associated with any `BaseRenderer`."
        raise KeyError(msg)
    return _registry[identifier]()




##############


class AggregateRenderer(Renderer):
    """A renderer that aggregates compatible renderers so they can all be used
    to render a view of the environment.

    Parameters
    ----------
    renderers : List[Renderer]
        A list of renderers to aggregate.

    Attributes
    ----------
    renderers : List[Renderer]
        A list of renderers to aggregate.
    """

    def __init__(self, renderers: List[Renderer]) -> None:
        super().__init__()
        self.renderers = renderers

    def render(self, env: 'TradingEnv', **kwargs) -> None:
        for r in self.renderers:
            r.render(env, **kwargs)

    def save(self) -> None:
        for r in self.renderers:
            r.save()

    def reset(self) -> None:
        for r in self.renderers:
            r.reset()

    def close(self) -> None:
        for r in self.renderers:
            r.close()



# [ END OF CHUNK 6 ]








# [ CHUNK 7 of 15 ] Logging_Debugging



import logging
from tensortrade.Logging.Logging_Debugging import Logging_Debugging
import sagemaker
from sagemaker.debugger import DebuggerHookConfig, CollectionConfig
from sagemaker.tensorflow import TensorFlow

def initialize_logging():
    """
    Initialize logging for recording events and errors.
    """
    logger = logging.getLogger(__name__)
    logger.setLevel(logging.DEBUG)
    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')

    # File handler to save logs to a file
    file_handler = logging.FileHandler('trading_env.log')
    file_handler.setFormatter(formatter)
    logger.addHandler(file_handler)

    # Console handler to print logs to the console
    console_handler = logging.StreamHandler()
    console_handler.setFormatter(formatter)
    logger.addHandler(console_handler)

    logger.debug("Trading environment initialized")


def configure_sagemaker_debugger():
    """
    Configure SageMaker Debugger for monitoring and debugging TensorFlow training jobs.
    """
    sagemaker_session = sagemaker.Session()

    # Debugger configuration with specific collections for reinforcement learning
    debugger_hook_config = DebuggerHookConfig(
        hook_parameters={
            "train.save_interval": "100",
            "eval.save_interval": "10"
        },
        collection_configs=[
            # Standard collections
            CollectionConfig(name="weights", parameters={"save_interval": "10"}),
            CollectionConfig(name="activations", parameters={"save_interval": "10"}),
            CollectionConfig(name="gradients", parameters={"save_interval": "10"}),
            CollectionConfig(name="loss", parameters={"save_interval": "10"}),
            CollectionConfig(name="metrics", parameters={"save_interval": "10"}),
            # RL-specific collections
            CollectionConfig(name="action_probabilities", parameters={"save_interval": "10"}),
            CollectionConfig(name="state_values", parameters={"save_interval": "10"}),
            CollectionConfig(name="reward_distributions", parameters={"save_interval": "10"}),
            CollectionConfig(name="policy_updates", parameters={"save_interval": "10"}),
            CollectionConfig(name="entropy", parameters={"save_interval": "10"}),
            # Add other collections as needed
        ]
    )

   # Define a SageMaker Estimator with Debugger Hook
estimator = TensorFlow(
    entry_point='training_script.py',  # Replace with your actual training script path
    role=sagemaker.get_execution_role(),
    instance_count=1,
    instance_type='ml.m5.xlarge',
    framework_version='2.3.0',
    py_version='py39',  # Update Python version to 3.9
    debugger_hook_config=debugger_hook_config,
    sagemaker_session=sagemaker_session,
    hyperparameters={
        'batch_size': 32,
        'epochs': 10,
        'learning_rate': 0.001
    }
)


    # Launch the training job
    estimator.fit({'train': 's3://path/to/your/training/data'})  # Replace with your actual S3 URI


if __name__ == "__main__":
    initialize_logging()
    configure_sagemaker_debugger()



# [ END OF CHUNK 7 ]









# [ CHUNK 8 of 15 ] Exchanges 

# Copyright 2019 The TensorTrade Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from typing import Callable
from decimal import Decimal

from tensortrade.core import Component, TimedIdentifiable
from tensortrade.oms.instruments import TradingPair


class ExchangeOptions:
    """An options class to specify the settings of an exchange.

    Parameters
    ----------
    commission : float, default 0.003
        The percentage of the order size taken by the exchange.
    min_trade_size : float, default 1e-6
        The minimum trade size an order can have.
    max_trade_size : float, default 1e6
        The maximum trade size an order can have.
    min_trade_price : float, default 1e-8
        The minimum price an exchange can have.
    max_trade_price : float, default 1e8
        The maximum price an exchange can have.
    is_live : bool, default False
        Whether live orders should be submitted to the exchange.
    """

    def __init__(self,
                 commission: float = 0.003,
                 min_trade_size: float = 1e-6,
                 max_trade_size: float = 1e6,
                 min_trade_price: float = 1e-8,
                 max_trade_price: float = 1e8,
                 is_live: bool = False):
        self.commission = commission
        self.min_trade_size = min_trade_size
        self.max_trade_size = max_trade_size
        self.min_trade_price = min_trade_price
        self.max_trade_price = max_trade_price
        self.is_live = is_live


class Exchange(Component, TimedIdentifiable):
    """An abstract exchange for use within a trading environment.

    Parameters
    ----------
    name : str
        The name of the exchange.
    service : `Union[Callable, str]`
        The service to be used for filling orders.
    options : `ExchangeOptions`
        The options used to specify the setting of the exchange.
    """

    registered_name = "exchanges"

    def __init__(self,
                 name: str,
                 service: Callable,
                 options: ExchangeOptions = None):
        super().__init__()
        self.name = name
        self._service = service
        self.options = options if options else ExchangeOptions()
        self._price_streams = {}

    def __call__(self, *streams) -> "Exchange":
        """Sets up the price streams used to generate the prices.

        Parameters
        ----------
        *streams
            The positional arguments each being a price stream.

        Returns
        -------
        `Exchange`
            The exchange the price streams were passed in for.
        """
        for s in streams:
            pair = "".join([c if c.isalnum() else "/" for c in s.name])
            self._price_streams[pair] = s.rename(self.name + ":/" + s.name)
        return self

    def streams(self) -> "List[Stream[float]]":
        """Gets the price streams for the exchange.

        Returns
        -------
        `List[Stream[float]]`
            The price streams for the exchange.
        """
        return list(self._price_streams.values())

    def quote_price(self, trading_pair: "TradingPair") -> "Decimal":
        """The quote price of a trading pair on the exchange, denoted in the
        core instrument.

        Parameters
        ----------
        trading_pair : `TradingPair`
            The trading pair to get the quote price for.

        Returns
        -------
        `Decimal`
            The quote price of the specified trading pair, denoted in the core instrument.
        """
        price = Decimal(self._price_streams[str(trading_pair)].value)
        if price == 0:
            raise ValueError("Price of trading pair {} is 0. Please check your input data to make sure there always is "
                             "a valid (nonzero) price.".format(trading_pair))

        price = price.quantize(Decimal(10) ** -trading_pair.base.precision)
        if price == 0:
            raise ValueError("Price quantized in base currency precision ({}) would amount to 0 {}. "
                             "Please consider defining a custom instrument with a higher precision."
                             .format(trading_pair.base.precision, trading_pair.base))

        return price

    def is_pair_tradable(self, trading_pair: 'TradingPair') -> bool:
        """Whether or not the specified trading pair is tradable on this
        exchange.

        Parameters
        ----------
        trading_pair : `TradingPair`
            The trading pair to test the tradability of.

        Returns
        -------
        bool
            Whether or not the pair is tradable.
        """
        return str(trading_pair) in self._price_streams.keys()

    def execute_order(self, order: 'Order', portfolio: 'Portfolio') -> None:
        """Execute an order on the exchange.

        Parameters
        ----------
        order: `Order`
            The order to execute.
        portfolio : `Portfolio`
            The portfolio to use.
        """
        trade = self._service(
            order=order,
            base_wallet=portfolio.get_wallet(self.id, order.pair.base),
            quote_wallet=portfolio.get_wallet(self.id, order.pair.quote),
            current_price=self.quote_price(order.pair),
            options=self.options,
            clock=self.clock
        )

        if trade:
            order.fill(trade)


# [ END OF CHUNK 8 ]






# [ CHUNK 9 of 15 ] Ledger


from typing import List
from collections import namedtuple

import pandas as pd


Transaction = namedtuple('Transaction', [
    'poid',
    'step',
    'source',
    'target',
    'memo',
    'amount',
    'free',
    'locked',
    'locked_poid'
])


class Ledger:
    """A ledger to keep track of transactions that occur in the order
    management system."""

    def __init__(self):
        self.transactions: 'List[Transaction]' = []

    def commit(self,
               wallet: 'Wallet',
               quantity: 'Quantity',
               source: str,
               target: str,
               memo: str) -> None:
        """Commits a transaction to the ledger records.

        Parameters
        ----------
        wallet : `Wallet`
            The wallet involved in this transaction.
        quantity : `Quantity`
            The amount being used.
        source : str
            The source of funds being transferred.
        target : str
            The destination the funds are being transferred to.
        memo : str
            A description of the transaction.
        """
        poid = quantity.path_id
        locked_poid_balance = None if poid not in wallet.locked.keys() else wallet.locked[poid]

        transaction = Transaction(
            poid,
            wallet.exchange.clock.step,
            source,
            target,
            memo,
            quantity,
            wallet.balance,
            wallet.locked_balance,
            locked_poid_balance
        )

        self.transactions += [transaction]

    def as_frame(self, sort_by_order_seq: bool = False) -> 'pd.DataFrame':
        """Converts the ledger records into a data frame.

        Parameters
        ----------
        sort_by_order_seq : bool, default False
            If records should be sorted by each order path.

        Returns
        -------
        `pd.DataFrame`
            A data frame containing all the records in the ledger.
        """

        if not sort_by_order_seq:
            return pd.DataFrame(self.transactions)

        df = pd.DataFrame(self.transactions)
        frames = []
        for poid in df.poid.unique():
            frames += [df.loc[df.poid == poid, :]]

        return pd.concat(frames, ignore_index=True, axis=0)

    def reset(self):
        """Resets the ledger."""
        self.transactions = []

# [ END OF CHUNK 9 ]








# [ CHUNK 10 of 15 ] Portfolio


# Copyright 2019 The TensorTrade Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License

import re

from typing import Callable, Tuple, List, TypeVar


from tensortrade.core import Component, TimedIdentifiable
from tensortrade.oms.exchanges import Exchange
from tensortrade.oms.orders import OrderListener
from tensortrade.oms.instruments import Instrument, Quantity, ExchangePair
from tensortrade.oms.wallets.wallet import Wallet
from tensortrade.oms.wallets.ledger import Ledger
from collections import OrderedDict


WalletType = TypeVar("WalletType", Wallet, Tuple[Exchange, Instrument, float])


class Portfolio(Component, TimedIdentifiable):
    """A portfolio of wallets on exchanges.

    Parameters
    ----------
    base_instrument : `Instrument`
        The exchange instrument used to measure value and performance statistics.
    wallets : `List[WalletType]`
        The wallets to be used in the portfolio.
    order_listener : `OrderListener`
        The order listener to set for all orders executed by this portfolio.
    performance_listener : `Callable[[OrderedDict], None]`
        The performance listener to send all portfolio updates to.
    """

    registered_name = "portfolio"

    def __init__(self,
                 base_instrument: Instrument,
                 wallets: List[WalletType] = None,
                 order_listener: 'OrderListener' = None,
                 performance_listener: Callable[[OrderedDict], None] = None):
        super().__init__()

        wallets = wallets or []

        self.base_instrument = self.default('base_instrument', base_instrument)
        self.order_listener = self.default('order_listener', order_listener)
        self.performance_listener = self.default('performance_listener', performance_listener)
        self._wallets = {}

        for wallet in wallets:
            self.add(wallet)

        self._initial_balance = self.base_balance
        self._initial_net_worth = None
        self._net_worth = None
        self._performance = None
        self._keys = None

    @property
    def wallets(self) -> 'List[Wallet]':
        """All the wallets in the portfolio. (`List[Wallet]`, read-only)"""
        return list(self._wallets.values())

    @property
    def exchanges(self) -> 'List[Exchange]':
        """All the exchanges in the portfolio. (`List[Exchange]`, read-only)"""
        exchanges = []
        for w in self.wallets:
            if w.exchange not in exchanges:
                exchanges += [w.exchange]
        return exchanges

    @property
    def ledger(self) -> 'Ledger':
        """The ledger that keeps track of transactions. (`Ledger`, read-only)"""
        return Wallet.ledger

    @property
    def exchange_pairs(self) -> 'List[ExchangePair]':
        """All the exchange pairs in the portfolio. (`List[ExchangePair]`, read-only)"""
        exchange_pairs = []
        for w in self.wallets:
            if w.instrument != self.base_instrument:
                exchange_pairs += [ExchangePair(w.exchange, self.base_instrument/w.instrument)]
        return exchange_pairs

    @property
    def initial_balance(self) -> 'Quantity':
        """The initial balance of the base instrument over all wallets. (`Quantity`, read-only)"""
        return self._initial_balance

    @property
    def base_balance(self) -> 'Quantity':
        """The current balance of the base instrument over all wallets. (`Quantity`, read-only)"""
        return self.balance(self.base_instrument)

    @property
    def initial_net_worth(self) -> float:
        """The initial net worth of the portfolio. (float, read-only)"""
        return self._initial_net_worth

    @property
    def net_worth(self) -> float:
        """The current net worth of the portfolio. (float, read-only)"""
        return self._net_worth

    @property
    def profit_loss(self) -> float:
        """The percent loss in net worth since the last reset. (float, read-only)"""
        return 1.0 - self.net_worth / self.initial_net_worth

    @property
    def performance(self) -> 'OrderedDict':
        """The performance of the portfolio since the last reset. (`OrderedDict`, read-only)"""
        return self._performance

    @property
    def balances(self) -> 'List[Quantity]':
        """The current unlocked balance of each instrument over all wallets. (`List[Quantity]`, read-only)"""
        return [wallet.balance for wallet in self._wallets.values()]

    @property
    def locked_balances(self) -> 'List[Quantity]':
        """The current locked balance of each instrument over all wallets. (`List[Quantity]`, read-only)"""
        return [wallet.locked_balance for wallet in self._wallets.values()]

    @property
    def total_balances(self) -> 'List[Quantity]':
        """The current total balance of each instrument over all wallets. (`List[Quantity]`, read-only)"""
        return [wallet.total_balance for wallet in self._wallets.values()]

    def balance(self, instrument: Instrument) -> 'Quantity':
        """Gets the total balance of the portfolio in a specific instrument
        available for use.

        Parameters
        ----------
        instrument : `Instrument`
            The instrument to compute the balance for.

        Returns
        -------
        `Quantity`
            The balance of the instrument over all wallets.
        """
        balance = Quantity(instrument, 0)

        for (_, symbol), wallet in self._wallets.items():
            if symbol == instrument.symbol:
                balance += wallet.balance

        return balance

    def locked_balance(self, instrument: Instrument) -> 'Quantity':
        """Gets the total balance a specific instrument locked in orders over
        the entire portfolio.

        Parameters
        ----------
        instrument : `Instrument`
            The instrument to find locked balances for.

        Returns
        -------
        `Quantity`
            The total locked balance of the instrument.
        """
        balance = Quantity(instrument, 0)

        for (_, symbol), wallet in self._wallets.items():
            if symbol == instrument.symbol:
                balance += wallet.locked_balance

        return balance

    def total_balance(self, instrument: Instrument) -> 'Quantity':
        """Gets the total balance of a specific instrument over the portfolio,
        both available for use and locked in orders.

        Parameters
        ----------
        instrument : `Instrument`
            The instrument to get total balance of.

        Returns
        -------
        `Quantity`
            The total balance of `instrument` over the portfolio.
        """
        return self.balance(instrument) + self.locked_balance(instrument)

    def get_wallet(self, exchange_id: str, instrument: 'Instrument') -> 'Wallet':
        """Gets wallet by the `exchange_id` and `instrument`.

        Parameters
        ----------
        exchange_id : str
            The exchange id used to identify the wallet.
        instrument : `Instrument`
            The instrument used to identify the wallet.

        Returns
        -------
        `Wallet`
            The wallet associated with `exchange_id` and `instrument`.
        """
        return self._wallets[(exchange_id, instrument.symbol)]

    def add(self, wallet: WalletType) -> None:
        """Adds a wallet to the portfolio.

        Parameters
        ----------
        wallet : `WalletType`
            The wallet to add to the portfolio.
        """
        if isinstance(wallet, tuple):
            wallet = Wallet.from_tuple(wallet)
        self._wallets[(wallet.exchange.id, wallet.instrument.symbol)] = wallet

    def remove(self, wallet: 'Wallet') -> None:
        """Removes a wallet from the portfolio.

        Parameters
        ----------
        wallet : `Wallet`
            The wallet to be removed.
        """
        self._wallets.pop((wallet.exchange.id, wallet.instrument.symbol), None)

    def remove_pair(self, exchange: 'Exchange', instrument: 'Instrument') -> None:
        """Removes a wallet from the portfolio by `exchange` and `instrument`.

        Parameters
        ----------
        exchange : `Exchange`
            The exchange of the wallet to be removed.
        instrument : `Instrument`
            The instrument of the wallet to be removed.
        """
        self._wallets.pop((exchange.id, instrument.symbol), None)

    @staticmethod
    def _find_keys(data: dict) -> 'List[str]':
        """Finds the keys that can attributed to the net worth of the portfolio.

        Parameters
        ----------
        data : dict
            The observer feed data point to search for keys attributed to net
            worth.

        Returns
        -------
        `List[str]`
            The list of strings attributed to net worth.
        """
        price_pattern = re.compile("\\w+:/([A-Z]{3,4}).([A-Z]{3,4})")
        endings = [
            ":/free",
            ":/locked",
            ":/total",
            "worth"
        ]

        keys = []
        for k in data.keys():
            if any(k.endswith(end) for end in endings):
                keys += [k]
            elif price_pattern.match(k):
                keys += [k]

        return keys

    def on_next(self, data: dict) -> None:
        """Updates the performance metrics.

        Parameters
        ----------
        data : dict
            The data produced from the observer feed that is used to
            update the performance metrics.
        """
        data = data["internal"]

        if not self._keys:
            self._keys = self._find_keys(data)

        index = self.clock.step
        performance_data = {k: data[k] for k in self._keys}
        performance_data['base_symbol'] = self.base_instrument.symbol
        performance_step = OrderedDict()
        performance_step[index] = performance_data

        net_worth = data['net_worth']

        if self._performance is None:
            self._performance = performance_step
            self._initial_net_worth = net_worth
            self._net_worth = net_worth
        else:
            self._performance.update(performance_step)
            self._net_worth = net_worth

        if self.performance_listener:
            self.performance_listener(performance_step)

    def reset(self) -> None:
        """Resets the portfolio."""
        self._initial_balance = self.base_balance
        self._initial_net_worth = None
        self._net_worth = None
        self._performance = None

        self.ledger.reset()
        for wallet in self._wallets.values():
            wallet.reset()

# [ END OF CHUNK 10 ]








# [ CHUNK 11 of 15 ] Wallet

# Copyright 2020 The TensorTrade Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License

from typing import Dict, Tuple
from collections import namedtuple
from decimal import Decimal

import numpy as np

from tensortrade.core import Identifiable
from tensortrade.core.exceptions import (
    InsufficientFunds,
    DoubleLockedQuantity,
    DoubleUnlockedQuantity,
    QuantityNotLocked
)
from tensortrade.oms.instruments import Instrument, Quantity, ExchangePair
from tensortrade.oms.orders import Order
from tensortrade.oms.exchanges import Exchange
from tensortrade.oms.wallets.ledger import Ledger

from tensortrade.feed import DataFetch
from tensortrade.oms.instruments import USD, Instrument


Transfer = namedtuple("Transfer", ["quantity", "commission", "price"])


class Wallet(Identifiable):
    """A wallet stores the balance of a specific instrument on a specific exchange.

    Parameters
    ----------
    exchange : `Exchange`
        The exchange associated with this wallet.
    balance : `Quantity`
        The initial balance quantity for the wallet.
    """

    ledger = Ledger()

    def __init__(self, exchange: 'Exchange', balance: 'Quantity'):
        self.exchange = exchange
        self._initial_size = balance.size
        self.instrument = balance.instrument
        self.balance = balance.quantize()
        self._locked = {}

    @property
    def locked_balance(self) -> 'Quantity':
        """The total balance of the wallet locked in orders. (`Quantity`, read-only)"""
        locked_balance = Quantity(self.instrument, 0)

        for quantity in self._locked.values():
            locked_balance += quantity.size

        return locked_balance

    @property
    def total_balance(self) -> 'Quantity':
        """The total balance of the wallet available for use and locked in orders. (`Quantity`, read-only)"""
        total_balance = self.balance

        for quantity in self._locked.values():
            total_balance += quantity.size

        return total_balance

    @property
    def locked(self) -> 'Dict[str, Quantity]':
        """The current quantities that are locked for orders. (`Dict[str, Quantity]`, read-only)"""
        return self._locked

    def lock(self, quantity, order: 'Order', reason: str) -> 'Quantity':
        """Locks funds for specified order.

        Parameters
        ----------
        quantity : `Quantity`
            The amount of funds to lock for the order.
        order : `Order`
            The order funds will be locked for.
        reason : str
            The reason for locking funds.

        Returns
        -------
        `Quantity`
            The locked quantity for `order`.

        Raises
        ------
        DoubleLockedQuantity
            Raised if the given amount is already a locked quantity.
        InsufficientFunds
            Raised if amount is greater the current balance.
        """
        if quantity.is_locked:
            raise DoubleLockedQuantity(quantity)

        if quantity > self.balance:
            if (quantity-self.balance)>Decimal(10)**(-self.instrument.precision+2):
                raise InsufficientFunds(self.balance, quantity)
            else:
                quantity = self.balance

        self.balance -= quantity

        quantity = quantity.lock_for(order.path_id)

        if quantity.path_id not in self._locked:
            self._locked[quantity.path_id] = quantity
        else:
            self._locked[quantity.path_id] += quantity

        self._locked[quantity.path_id] = self._locked[quantity.path_id].quantize()
        self.balance = self.balance.quantize()

        self.ledger.commit(wallet=self,
                           quantity=quantity,
                           source="{}:{}/free".format(self.exchange.name, self.instrument),
                           target="{}:{}/locked".format(self.exchange.name, self.instrument),
                           memo="LOCK ({})".format(reason))

        return quantity

    def unlock(self, quantity: 'Quantity', reason: str) -> 'Quantity':
        """Unlocks a certain amount from the locked funds of the wallet that
        are associated with the given `quantity` path id.

        Parameters
        ----------
        quantity : `Quantity`
            The quantity to unlock from the funds.
        reason : str
            The reason for unlocking funds.

        Returns
        -------
        `Quantity`
            The free quantity.

        Raises
        ------
        DoubleUnlockedFunds
            Raised if `quantity` is not a locked quantity.
        QuantityNotLocked
            Raised if  `quantity` has a path id that is not currently allocated
            in this wallet.
        InsufficientFunds
            Raised if `quantity` is greater than the amount currently allocated
            for the associated path id.
        """
        if not quantity.is_locked:
            raise DoubleUnlockedQuantity(quantity)

        if quantity.path_id not in self._locked:
            raise QuantityNotLocked(quantity)

        if quantity > self._locked[quantity.path_id]:
            raise InsufficientFunds(self._locked[quantity.path_id], quantity)

        self._locked[quantity.path_id] -= quantity
        self.balance += quantity.free()

        self._locked[quantity.path_id] = self._locked[quantity.path_id].quantize()
        self.balance = self.balance.quantize()

        self.ledger.commit(wallet=self,
                           quantity=quantity,
                           source="{}:{}/locked".format(self.exchange.name, self.instrument),
                           target="{}:{}/free".format(self.exchange.name, self.instrument),
                           memo="UNLOCK {} ({})".format(self.instrument, reason))

        return quantity

    def deposit(self, quantity: 'Quantity', reason: str) -> 'Quantity':
        """Deposits funds into the wallet.

        Parameters
        ----------
        quantity : `Quantity`
            The amount to deposit into this wallet.
        reason : str
            The reason for depositing the amount.

        Returns
        -------
        `Quantity`
            The deposited amount.
        """
        if quantity.is_locked:
            if quantity.path_id not in self._locked:
                self._locked[quantity.path_id] = quantity
            else:
                self._locked[quantity.path_id] += quantity
        else:
            self.balance += quantity

        self.balance = self.balance.quantize()

        self.ledger.commit(wallet=self,
                           quantity=quantity,
                           source=self.exchange.name,
                           target="{}:{}/locked".format(self.exchange.name, self.instrument),
                           memo="DEPOSIT ({})".format(reason))

        return quantity

    def withdraw(self, quantity: 'Quantity', reason: str) -> 'Quantity':
        """Withdraws funds from the wallet.

        Parameters
        ----------
        quantity : `Quantity`
            The amount to withdraw from this wallet.
        reason : str
            The reason for withdrawing the amount.

        Returns
        -------
        `Quantity`
            The withdrawn amount.
        """
        if quantity.is_locked and self._locked.get(quantity.path_id, False):
            locked_quantity = self._locked[quantity.path_id]
            if quantity > locked_quantity:
                if (quantity-locked_quantity)>Decimal(10)**(-self.instrument.precision+2):
                    raise InsufficientFunds(locked_quantity, quantity)
                else:
                    quantity = locked_quantity
            self._locked[quantity.path_id] -= quantity

        elif not quantity.is_locked:
            if quantity > self.balance:
                if (quantity-self.balance)>Decimal(10)**(-self.instrument.precision+2):
                    raise InsufficientFunds(self.balance, quantity)
                else:
                    quantity = self.balance
            self.balance -= quantity

        self.balance = self.balance.quantize()

        self.ledger.commit(wallet=self,
                           quantity=quantity,
                           source="{}:{}/locked".format(self.exchange.name, self.instrument),
                           target=self.exchange.name,
                           memo="WITHDRAWAL ({})".format(reason))

        return quantity

    @classmethod
    def from_tuple(cls, wallet_tuple: 'Tuple[Exchange, Instrument, float]') -> 'Wallet':
        """Creates a wallet from a wallet tuple.

        Parameters
        ----------
        wallet_tuple : `Tuple[Exchange, Instrument, float]`
            A tuple containing an exchange, instrument, and amount.

        Returns
        -------
        `Wallet`
            A wallet corresponding to the arguments given in the tuple.
        """
        exchange, instrument, balance = wallet_tuple
        return cls(exchange, Quantity(instrument, balance))

    @staticmethod
    def transfer(source: 'Wallet',
                 target: 'Wallet',
                 quantity: 'Quantity',
                 commission: 'Quantity',
                 exchange_pair: 'ExchangePair',
                 reason: str) -> 'Transfer':
        """Transfers funds from one wallet to another.

        Parameters
        ----------
        source : `Wallet`
            The wallet in which funds will be transferred from
        target : `Wallet`
            The wallet in which funds will be transferred to
        quantity : `Quantity`
            The quantity to be transferred from the source to the target.
            In terms of the instrument of the source wallet.
        commission :  `Quantity`
            The commission to be taken from the source wallet for performing
            the transfer of funds.
        exchange_pair : `ExchangePair`
            The exchange pair associated with the transfer
        reason : str
            The reason for transferring the funds.

        Returns
        -------
        `Transfer`
            A transfer object describing the transaction.

        Raises
        ------
        Exception
            Raised if an equation that describes the conservation of funds
            is broken.
        """
        quantity = quantity.quantize()
        commission = commission.quantize()

        pair = source.instrument / target.instrument
        poid = quantity.path_id

        lsb1 = source.locked.get(poid).size
        ltb1 = target.locked.get(poid, 0 * pair.quote).size

        if commission.as_float() > 0.0:
            commission = source.withdraw(commission, "COMMISSION")

        quantity = source.withdraw(quantity, "FILL ORDER")

        if quantity.instrument == exchange_pair.pair.base:
            instrument = exchange_pair.pair.quote
            converted_size = quantity.size / exchange_pair.price
        else:
            instrument = exchange_pair.pair.base
            converted_size = quantity.size * exchange_pair.price

        converted = Quantity(instrument, converted_size, quantity.path_id).quantize()

        converted = target.deposit(converted, 'TRADED {} {} @ {}'.format(quantity,
                                                                         exchange_pair,
                                                                         exchange_pair.price))

        lsb2 = source.locked.get(poid).size
        ltb2 = target.locked.get(poid, 0 * pair.quote).size

        q = quantity.size
        c = commission.size
        cv = converted.size
        p = exchange_pair.inverse_price if pair == exchange_pair.pair else exchange_pair.price

        source_quantization = Decimal(10) ** -source.instrument.precision
        target_quantization = Decimal(10) ** -target.instrument.precision

        lhs = Decimal((lsb1 - lsb2) - (q + c)).quantize(source_quantization)
        rhs = Decimal(ltb2 - ltb1 - cv).quantize(target_quantization)

        lhs_eq_zero = np.isclose(float(lhs), 0, atol=float(source_quantization))
        rhs_eq_zero = np.isclose(float(rhs), 0, atol=float(target_quantization))

        if not lhs_eq_zero or not rhs_eq_zero:
            equation = "({} - {}) - ({} + {}) != ({} - {}) - {}   [LHS = {}, RHS = {}, Price = {}]".format(
                lsb1, lsb2, q, c, ltb2, ltb1, cv, lhs, rhs, p
            )

            raise Exception("Invalid Transfer: " + equation)

        return Transfer(quantity, commission, exchange_pair.price)

    def reset(self) -> None:
        """Resets the wallet."""
        self.balance = Quantity(self.instrument, self._initial_size).quantize()
        self._locked = {}

    def __str__(self) -> str:
        return '<Wallet: balance={}, locked={}>'.format(self.balance, self.locked_balance)

    def __repr__(self) -> str:
        return str(self)


# [ END OF CHUNK 11 ]









# [ CHUNK 12 of 15 ] Environment __init__





from typing import Union

from tensortrade.env.generic.components.reward_scheme import RewardScheme


from tensortrade.env.generic import environment
from tensortrade.env.generic.environment import TradingEnv

from custom_components.my_custom_rewards import CustomRewardScheme

from tensortrade.env.generic import actions
from tensortrade.env.generic import observers
from tensortrade.env.generic import stoppers
from tensortrade.env.generic import informer
from tensortrade.env.generic import renderers


from tensortrade.env.generic.renderers import AggregateRenderer
from tensortrade.feed.core import DataFeed
from tensortrade.oms.wallets import Portfolio





def create(portfolio: Portfolio,
           action_scheme: Union[tensortrade.env.generic.actions.TensorTradeActionScheme, str],  #TensorTradeActionScheme
           reward_scheme: Union[custom_components.my_custom_rewards.CustomRewardScheme, str],

           feed: DataFeed,
           window_size: int = 1,
           min_periods: int = None,
           random_start_pct: float = 0.00,
           **kwargs) -> TradingEnv:
    """Creates the default `TradingEnv` of the project to be used in training
    RL agents.

    Parameters
    ----------
    portfolio : `Portfolio`
        The portfolio to be used by the environment.
    action_scheme : `actions.TensorTradeActionScheme` or str
        The action scheme for computing actions at every step of an episode.
    reward_scheme : `rewards.TensorTradeRewardScheme` or str
        The reward scheme for computing rewards at every step of an episode.
    feed : `DataFeed`
        The feed for generating observations to be used in the look back
        window.
    window_size : int
        The size of the look back window to use for the observation space.
    min_periods : int, optional
        The minimum number of steps to warm up the `feed`.
    random_start_pct : float, optional
        Whether to randomize the starting point within the environment at each
        observer reset, starting in the first X percentage of the sample
    **kwargs : keyword arguments
        Extra keyword arguments needed to build the environment.

    Returns
    -------
    `TradingEnv`
        The default trading environment.
    """

    if isinstance(action_scheme, str):
        action_scheme = getattr(TensorTradeActionScheme, action_scheme)()
    elif not isinstance(action_scheme, TensorTradeActionScheme):
        raise ValueError("action_scheme must be an instance of TensorTradeActionScheme or a valid subclass identifier string.")
    
    action_scheme.portfolio = portfolio

    if isinstance(reward_scheme, str):
        reward_scheme = getattr(CustomRewardScheme, reward_scheme)()
    elif not isinstance(reward_scheme, CustomRewardScheme):
        raise ValueError("reward_scheme must be an instance of CustomRewardScheme or a valid subclass identifier string.")

    observer = observers.TensorTradeObserver(
        portfolio=portfolio,
        feed=feed,
        renderer_feed=kwargs.get('renderer_feed', None),
        window_size=window_size,
        min_periods=min_periods
    )

    stopper = stoppers.MaxLossStopper(
        max_allowed_loss=kwargs.get('max_allowed_loss', 0.5)
    )

    # Handle renderer initialization
    renderer_input = kwargs.get('renderer', renderers.EmptyRenderer())
    if isinstance(renderer_input, list):
        renderer_list = []
        for r in renderer_input:
            if isinstance(r, str):
                renderer_list.append(renderers.get(r))
            else:
                renderer_list.append(r)
        renderer = renderers.AggregateRenderer(renderer_list)
    elif isinstance(renderer_input, str):
        renderer = renderers.get(renderer_input)
    else:
        renderer = renderer_input

    env = TradingEnv(
        action_scheme=action_scheme,
        reward_scheme=reward_scheme,
        observer=observer,
        stopper=stopper,
        informer=kwargs.get('informer', informer.TensorTradeInformer()),
        renderer=renderer,
        min_periods=min_periods,
        random_start_pct=random_start_pct,
    )
    return env




# [ END OF CHUNK 12 ]













# [ CHUNK 13 of 15 ] Actions


import logging
from abc import abstractmethod
from itertools import product
from typing import Union, List, Any

from gym.spaces import Space, Discrete

from tensortrade.core import Clock
from tensortrade.env.generic import ActionScheme, TradingEnv
from tensortrade.oms.instruments import ExchangePair
from tensortrade.oms.orders import (
    Broker,
    Order,
    OrderListener,
    OrderSpec,
    proportion_order,
    risk_managed_order,
    TradeSide,
    TradeType
)
from tensortrade.oms.wallets import Portfolio

from abc import abstractmethod, ABCMeta
from typing import Any

from gym.spaces import Space


from tensortrade.core.component import Component
from tensortrade.core.base import TimeIndexed



class TensorTradeActionScheme(ActionScheme):
    """An abstract base class for any `ActionScheme` that wants to be
    compatible with the built in OMS.

    The structure of the action scheme is built to make sure that action space
    can be used with the system, provided that the user defines the methods to
    interpret that action.

    Attributes
    ----------
    portfolio : 'Portfolio'
        The portfolio object to be used in defining actions.
    broker : 'Broker'
        The broker object to be used for placing orders in the OMS.

    Methods
    -------
    perform(env,portfolio)
        Performs the action on the given environment.
    get_orders(action,portfolio)
        Gets the list of orders to be submitted for the given action.
    """

    def __init__(self) -> None:
        super().__init__()
        self.portfolio: 'Portfolio' = None
        self.broker: 'Broker' = Broker()

    @property
    def clock(self) -> 'Clock':
        """The reference clock from the environment. (`Clock`)

        When the clock is set for the we also set the clock for the portfolio
        as well as the exchanges defined in the portfolio.

        Returns
        -------
        `Clock`
            The environment clock.
        """
        return self._clock

    @clock.setter
    def clock(self, clock: 'Clock') -> None:
        self._clock = clock

        components = [self.portfolio] + self.portfolio.exchanges
        for c in components:
            c.clock = clock
        self.broker.clock = clock

    def perform(self, env: 'TradingEnv', action: Any) -> None:
        """Performs the action on the given environment.

        Under the TT action scheme, the subclassed action scheme is expected
        to provide a method for getting a list of orders to be submitted to
        the broker for execution in the OMS.

        Parameters
        ----------
        env : 'TradingEnv'
            The environment to perform the action on.
        action : Any
            The specific action selected from the action space.
        """
        orders = self.get_orders(action, self.portfolio)

        for order in orders:
            if order:
                logging.info('Step {}: {} {}'.format(order.step, order.side, order.quantity))
                self.broker.submit(order)

        self.broker.update()

    @abstractmethod
    def get_orders(self, action: Any, portfolio: 'Portfolio') -> 'List[Order]':
        """Gets the list of orders to be submitted for the given action.

        Parameters
        ----------
        action : Any
            The action to be interpreted.
        portfolio : 'Portfolio'
            The portfolio defined for the environment.

        Returns
        -------
        List[Order]
            A list of orders to be submitted to the broker.
        """
        raise NotImplementedError()

    def reset(self) -> None:
        """Resets the action scheme."""
        self.portfolio.reset()
        self.broker.reset()


class BSH(TensorTradeActionScheme):
    """A simple discrete action scheme where the only options are to buy, sell,
    or hold.

    Parameters
    ----------
    cash : `Wallet`
        The wallet to hold funds in the base intrument.
    asset : `Wallet`
        The wallet to hold funds in the quote instrument.
    """

    registered_name = "bsh"

    def __init__(self, cash: 'Wallet', asset: 'Wallet'):
        super().__init__()
        self.cash = cash
        self.asset = asset

        self.listeners = []
        self.action = 0

    @property
    def action_space(self):
        return Discrete(2)

    def attach(self, listener):
        self.listeners += [listener]
        return self

    def get_orders(self, action: int, portfolio: 'Portfolio') -> 'Order':
        order = None

        if abs(action - self.action) > 0:
            src = self.cash if self.action == 0 else self.asset
            tgt = self.asset if self.action == 0 else self.cash

            if src.balance == 0:  # We need to check, regardless of the proposed order, if we have balance in 'src'
                return []  # Otherwise just return an empty order list

            order = proportion_order(portfolio, src, tgt, 1.0)
            self.action = action

        for listener in self.listeners:
            listener.on_action(action)

        return [order]

    def reset(self):
        super().reset()
        self.action = 0


class SimpleOrders(TensorTradeActionScheme):
    """A discrete action scheme that determines actions based on a list of
    trading pairs, order criteria, and trade sizes.

    Parameters
    ----------
    criteria : List[OrderCriteria]
        A list of order criteria to select from when submitting an order.
        (e.g. MarketOrder, LimitOrder w/ price, StopLoss, etc.)
    trade_sizes : List[float]
        A list of trade sizes to select from when submitting an order.
        (e.g. '[1, 1/3]' = 100% or 33% of balance is tradable.
        '4' = 25%, 50%, 75%, or 100% of balance is tradable.)
    durations : List[int]
        A list of durations to select from when submitting an order.
    trade_type : TradeType
        A type of trade to make.
    order_listener : OrderListener
        A callback class to use for listening to steps of the order process.
    min_order_pct : float
        The minimum value when placing an order, calculated in percent over net_worth.
    min_order_abs : float
        The minimum value when placing an order, calculated in absolute order value.
    """

    def __init__(self,
                 criteria: 'Union[List[OrderCriteria], OrderCriteria]' = None,
                 trade_sizes: 'Union[List[float], int]' = 10,
                 durations: 'Union[List[int], int]' = None,
                 trade_type: 'TradeType' = TradeType.MARKET,
                 order_listener: 'OrderListener' = None,
                 min_order_pct: float = 0.02,
                 min_order_abs: float = 0.00) -> None:
        super().__init__()
        self.min_order_pct = min_order_pct
        self.min_order_abs = min_order_abs
        criteria = self.default('criteria', criteria)
        self.criteria = criteria if isinstance(criteria, list) else [criteria]

        trade_sizes = self.default('trade_sizes', trade_sizes)
        if isinstance(trade_sizes, list):
            self.trade_sizes = trade_sizes
        else:
            self.trade_sizes = [(x + 1) / trade_sizes for x in range(trade_sizes)]

        durations = self.default('durations', durations)
        self.durations = durations if isinstance(durations, list) else [durations]

        self._trade_type = self.default('trade_type', trade_type)
        self._order_listener = self.default('order_listener', order_listener)

        self._action_space = None
        self.actions = None

    @property
    def action_space(self) -> Space:
        if not self._action_space:
            self.actions = product(
                self.criteria,
                self.trade_sizes,
                self.durations,
                [TradeSide.BUY, TradeSide.SELL]
            )
            self.actions = list(self.actions)
            self.actions = list(product(self.portfolio.exchange_pairs, self.actions))
            self.actions = [None] + self.actions

            self._action_space = Discrete(len(self.actions))
        return self._action_space

    def get_orders(self,
                   action: int,
                   portfolio: 'Portfolio') -> 'List[Order]':

        if action == 0:
            return []

        (ep, (criteria, proportion, duration, side)) = self.actions[action]

        instrument = side.instrument(ep.pair)
        wallet = portfolio.get_wallet(ep.exchange.id, instrument=instrument)

        balance = wallet.balance.as_float()
        size = (balance * proportion)
        size = min(balance, size)

        quantity = (size * instrument).quantize()

        if size < 10 ** -instrument.precision \
                or size < self.min_order_pct * portfolio.net_worth \
                or size < self.min_order_abs:
            return []

        order = Order(
            step=self.clock.step,
            side=side,
            trade_type=self._trade_type,
            exchange_pair=ep,
            price=ep.price,
            quantity=quantity,
            criteria=criteria,
            end=self.clock.step + duration if duration else None,
            portfolio=portfolio
        )

        if self._order_listener is not None:
            order.attach(self._order_listener)

        return [order]


class ManagedRiskOrders(TensorTradeActionScheme):
    """A discrete action scheme that determines actions based on managing risk,
       through setting a follow-up stop loss and take profit on every order.

    Parameters
    ----------
    stop : List[float]
        A list of possible stop loss percentages for each order.
    take : List[float]
        A list of possible take profit percentages for each order.
    trade_sizes : List[float]
        A list of trade sizes to select from when submitting an order.
        (e.g. '[1, 1/3]' = 100% or 33% of balance is tradable.
        '4' = 25%, 50%, 75%, or 100% of balance is tradable.)
    durations : List[int]
        A list of durations to select from when submitting an order.
    trade_type : `TradeType`
        A type of trade to make.
    order_listener : OrderListener
        A callback class to use for listening to steps of the order process.
    min_order_pct : float
        The minimum value when placing an order, calculated in percent over net_worth.
    min_order_abs : float
        The minimum value when placing an order, calculated in absolute order value.
    """

    def __init__(self,
                 stop: 'List[float]' = [0.02, 0.04, 0.06],
                 take: 'List[float]' = [0.01, 0.02, 0.03],
                 trade_sizes: 'Union[List[float], int]' = 10,
                 durations: 'Union[List[int], int]' = None,
                 trade_type: 'TradeType' = TradeType.MARKET,
                 order_listener: 'OrderListener' = None,
                 min_order_pct: float = 0.02,
                 min_order_abs: float = 0.00) -> None:
        super().__init__()
        self.min_order_pct = min_order_pct
        self.min_order_abs = min_order_abs
        self.stop = self.default('stop', stop)
        self.take = self.default('take', take)

        trade_sizes = self.default('trade_sizes', trade_sizes)
        if isinstance(trade_sizes, list):
            self.trade_sizes = trade_sizes
        else:
            self.trade_sizes = [(x + 1) / trade_sizes for x in range(trade_sizes)]

        durations = self.default('durations', durations)
        self.durations = durations if isinstance(durations, list) else [durations]

        self._trade_type = self.default('trade_type', trade_type)
        self._order_listener = self.default('order_listener', order_listener)

        self._action_space = None
        self.actions = None

    @property
    def action_space(self) -> 'Space':
        if not self._action_space:
            self.actions = product(
                self.stop,
                self.take,
                self.trade_sizes,
                self.durations,
                [TradeSide.BUY, TradeSide.SELL]
            )
            self.actions = list(self.actions)
            self.actions = list(product(self.portfolio.exchange_pairs, self.actions))
            self.actions = [None] + self.actions

            self._action_space = Discrete(len(self.actions))
        return self._action_space

    def get_orders(self, action: int, portfolio: 'Portfolio') -> 'List[Order]':

        if action == 0:
            return []

        (ep, (stop, take, proportion, duration, side)) = self.actions[action]

        side = TradeSide(side)

        instrument = side.instrument(ep.pair)
        wallet = portfolio.get_wallet(ep.exchange.id, instrument=instrument)

        balance = wallet.balance.as_float()
        size = (balance * proportion)
        size = min(balance, size)
        quantity = (size * instrument).quantize()

        if size < 10 ** -instrument.precision \
                or size < self.min_order_pct * portfolio.net_worth \
                or size < self.min_order_abs:
            return []

        params = {
            'side': side,
            'exchange_pair': ep,
            'price': ep.price,
            'quantity': quantity,
            'down_percent': stop,
            'up_percent': take,
            'portfolio': portfolio,
            'trade_type': self._trade_type,
            'end': self.clock.step + duration if duration else None
        }

        order = risk_managed_order(**params)

        if self._order_listener is not None:
            order.attach(self._order_listener)

        return [order]


_registry = {
    'bsh': BSH,
    'simple': SimpleOrders,
    'managed-risk': ManagedRiskOrders,
}


def get(identifier: str) -> 'ActionScheme':
    """Gets the `ActionScheme` that matches with the identifier.

    Parameters
    ----------
    identifier : str
        The identifier for the `ActionScheme`.

    Returns
    -------
    'ActionScheme'
        The action scheme associated with the `identifier`.

    Raises
    ------
    KeyError:
        Raised if the `identifier` is not associated with any `ActionScheme`.
    """
    if identifier not in _registry.keys():
        raise KeyError(f"Identifier {identifier} is not associated with any `ActionScheme`.")
    return _registry[identifier]()


####################




class ActionScheme(Component, TimeIndexed, metaclass=ABCMeta):
    """A component for determining the action to take at each step of an
    episode.
    """

    registered_name = "actions"

    @property
    @abstractmethod
    def action_space(self) -> Space:
        """The action space of the `TradingEnv`. (`Space`, read-only)
        """
        raise NotImplementedError()

    @abstractmethod
    def perform(self, env: 'TradingEnv', action: Any) -> None:
        """Performs an action on the environment.

        Parameters
        ----------
        env : `TradingEnv`
            The trading environment to perform the `action` on.
        action : Any
            The action to perform on `env`.
        """
        raise NotImplementedError()

    def reset(self) -> None:
        """Resets the action scheme."""
        pass


# [ END OF CHUNK 13 ]







# [ CHUNK 14 of 15 ] Informer

from tensortrade.env.generic.informer import Informer
from tensortrade.env.generic.environment import TradingEnv

class TensorTradeInformer(Informer):

    def __init__(self) -> None:
        super().__init__()

    def info(self, env: 'TradingEnv') -> dict:
        return {
            'step': self.clock.step,
            'net_worth': env.action_scheme.portfolio.net_worth
        }


# [ END OF CHUNK 14 ]







# [ CHUNK 15 of 15 ] Stopper

from tensortrade.env.generic.stoppers import Stopper, TradingEnv

class MaxLossStopper(Stopper):
    """A stopper that stops an episode if the portfolio has lost a particular
    percentage of its wealth.

    Parameters
    ----------
    max_allowed_loss : float
        The maximum percentage of initial funds that is willing to
        be lost before stopping the episode.

    Attributes
    ----------
    max_allowed_loss : float
        The maximum percentage of initial funds that is willing to
        be lost before stopping the episode.

    Notes
    -----
    This stopper also stops if it has reached the end of the observation feed.
    """

    def __init__(self, max_allowed_loss: float):
        super().__init__()
        self.max_allowed_loss = max_allowed_loss

    def stop(self, env: 'TradingEnv') -> bool:
        c1 = env.action_scheme.portfolio.profit_loss > self.max_allowed_loss
        c2 = not env.observer.has_next()
        return c1 or c2



# [ END OF CHUNK 15 ]
































